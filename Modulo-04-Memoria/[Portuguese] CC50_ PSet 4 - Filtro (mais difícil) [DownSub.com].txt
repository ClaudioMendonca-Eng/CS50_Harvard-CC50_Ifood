BRIAN: Vamos agora com tudo em: 
Filter

Em Filter, sua tarefa será
obter uma imagem bitmap

e aplicar alguns filtros
diferentes a essa imagem.

Você aplicará um filtro para pegar uma
imagem e convertê-la em tons de cinza,

tornando-a em preto e branco.

Você pegará a imagem e aplicará
um filtro para transformá-la

em sépia, dando a tudo um tom
marrom avermelhado, antigo.

Você vai pegar a imagem e
refleti-la, obtendo o espelhado

da imagem original.

E, finalmente, você aplicará um filtro
de desfoque que irá pegar a imagem

e suavizá-la para que os detalhes
fiquem um pouco menos claros.

Então, essas são as quatro
partes deste projeto.

Escala de cinza, sépia, reflexo e desfoque.

Mas como você vai aplicar
filtros às imagens?

Bem, cada imagem,
lembre-se, é uma sequência

de pixels individuais organizados
em uma grade específica.

E como representamos um pixel?

Bem, em uma tela de computador,
cada pixel tem três valores,

que podemos chamar de canais.

Um canal vermelho, um canal
verde e um canal azul,

onde esses valores variam de 0--

significando nenhum-- a 255--

significando o máximo.

Se definirmos o valor vermelho
para um valor pequeno,

você verá que temos um pouco
de vermelho no pixel.

Um valor de vermelho mais alto
significa mais vermelho no pixel.

E 255 significa que temos o máximo de
vermelho possível neste pixel em particular.

Nós o definimos de volta para
0, e o pixel volta para preto.

Por que o valor de cada
canal vai de 0 a 255?

Bem, 0 representado em binário é
apenas 0, como você pode imaginar.

E 255 representado em
binário são oito 1's,

o que significa que para cada valor de
cor, podemos usar um byte ou 8 bits

para cada cor - vermelho, verde e azul.

E como temos três desses, podemos
usar três bytes ou 24 bits por pixel.

Então, se você já ouviu
o termo cor de 24 bits,

é a isso que está se referindo.

Portanto, podemos usar o canal vermelho para
controlar a quantidade de vermelho neste pixel.

Podemos usar o canal verde para
controlar quanto verde há no pixel.

E podemos usar o canal azul para
controlar a quantidade de azul no pixel.

Mas é claro, não precisamos usar
apenas um dos canais de cada vez.

Podemos usá-los em combinação para criar
qualquer número de cores diferentes.

Se tivermos muito vermelho
e um pouco de azul,

temos uma cor que se
parece um pouco com esta.

E se tivermos muito verde e muito azul,
mas apenas um pouco de vermelho,

então temos uma cor turquesa que
se parece um pouco com isso.

E se definirmos cada um dos valores
de canal de vermelho, verde,

e azul até o valor máximo
de 255, bem, esse pixel

será apenas um pixel branco puro.

Se pegarmos o suficiente desses pixels,
defina-os com o valor de cor certo,

e organizá-los na
ordem apropriada,

o resultado é que podemos
ver uma imagem que

parece algo organizando as
cores na posição correta.

Então, com quais arquivos você 
precisa trabalhar neste problema?

Bem, existe o bmp.h, que armazena
informações sobre imagens de bitmap.

Vai armazenar algumas
das estruturas que você

vai precisar lidar com a fim
de completar esta tarefa.

Também fornecemos a você filter.c,
qual é o programa que você

executar para executar
esses filtros, o que vai

cuidar da lógica de leitura
do arquivo da memória,

chamando uma função para aplicar um filtro,
e, em seguida, gravar a nova imagem no disco

como um novo arquivo.

Helpers.c é o arquivo
que contém

todas as funções que
vão implementar

cada um dos filtros para esta
tarefa - desfoque, reflexo, sépia,

escala de cinza.

Helpers.h é o arquivo
de cabeçalho que vai

para declarar todas as funções que
aparecem em helpers.c, dizendo a você

qual é o tipo de retorno
da função e o que

todos os tipos de argumentos
para as funções são.

Finalmente, demos a você um makefile,
que quando você executa make

vai pegar todos esses
arquivos e combiná-los juntos

em um executável que você pode executar para
aplicar esses filtros às imagens

de sua propriedade.

Concluímos todos os
arquivos, exceto helpers.c,

e é aí que você entra.

Então, como você vai escrever o
código para implementar esses filtros?

Bem, em bmp.h, definimos
uma estrutura para você

chamado RGBTRIPLE, que vai
representar um pixel que

tem um valor vermelho, verde e azul.

Você notará que esta estrutura
possui três campos.

Um campo chamado rgbtBlue que representa
a quantidade de azul no triplo,

um campo chamado rgbtGreen que
representa a quantidade de verde,

e um campo denominado rgbtRed que
representa a quantidade de vermelho.

Cada campo armazena um byte
de informação - lembrando

que um byte tem apenas 8 bits.

Sua tarefa será implementar as
quatro funções em helpers.c;

tons de cinza, sépia, reflexo e desfoque.

Cada uma dessas funções
leva três argumentos.

Um inteiro denominado altura, um inteiro
denominado largura e um bidimensional

array de RGBTRIPLES -

um array 2D de pixels onde há linhas
de altura e colunas de largura.

Portanto, sua imagem pode ser
um pouco mais ou menos assim.

Um array bidimensional que
tem uma altura particular, que

será um argumento para sua função,
e tem uma largura particular, que

também será um argumento.

Então, se tivermos uma imagem
que é um array bidimensional,

image [0] vai representar a
primeira linha dessa imagem.

A imagem [1] representa a segunda linha.

A imagem [2] representa a terceira linha.

E assim por diante.

Como, por exemplo, você obteria
a última linha da imagem?

Bem, se houver altura muitas linhas na
imagem e começaremos a contar a partir de

linha 0, a última linha da
imagem será imagem [altura-1],

por exemplo.

É assim que você obtém
uma linha da imagem.

Mas como você chega a um pixel
muito específico nessa imagem?

Bem, a imagem [0] é uma linha da imagem,
que por si só é um array.

Portanto, se a imagem [0] é
a primeira linha da imagem,

image [0] [0] será o primeiro
pixel da primeira linha.

A imagem [0] [1] é o
segundo pixel da linha.

A imagem [0] [2] é o
terceiro pixel da linha.

E assim por diante.

E podemos usar essa notação para
acessar qualquer pixel na imagem.

A imagem [2] [3], por exemplo, é o
pixel na linha 2 e coluna 3 deste

imagem particular.

Então, se tivermos um pixel,
como nós 

podemos modificar o pixel para
alterar seus valores de cor?

Bem, lembre-se de que cada pixel é 
apenas uma estrutura que tem valores

rgbtRed, rgbtGreen e rgbtBlue.

Portanto, para acessar as propriedades de uma
estrutura, podemos usar a notação de ponto.

Usando image [2] [3] .rgbtRed para definir
o valor de vermelho do pixel igual a algo.

E fazendo o mesmo para os valores
de verde e azul, por exemplo.

Se definirmos o vermelho, verde,
e os valores de azul são todos para 0,

então vamos tornar
este pixel preto

porque preto é a cor
representada por valores de 0

para cada um de vermelho, verde e azul.

Sua tarefa em cada uma dessas funções -
tons de cinza, sépia, reflexo e desfoque -

vai tomar a imagem como entrada,
como esse array bidimensional,

e modificar o array bidimensional,
mudando os pixels individuais

para criar o efeito que você obteria
aplicando um desses filtros.

