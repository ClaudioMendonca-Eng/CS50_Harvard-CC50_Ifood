# CS50_Harvard-CC50_Ifood

Estou empolgado para compartilhar sobre a nova versão do CC50, o curso introdutório de Ciência da Computação de Harvard, que está repleto de conteúdo e novidades incríveis! Esse curso renomado mundialmente oferece uma sólida base em computação, Internet, programação e muito mais, tudo de forma gratuita.

Durante o curso, exploramos o funcionamento de computadores, a Internet e desenvolvemos habilidades em programação. Ao término, estaremos prontos para iniciar projetos em áreas como Web Design, Bancos de Dados, Sistemas Eletrônicos e Programação de Software. Apesar de desafiador, o curso é acessível a todos, independentemente da experiência em programação.

O professor David J. Malan utiliza uma didática incrível, tornando o aprendizado ainda mais enriquecedor. Todos os materiais, incluindo a tradução das aulas e dos Sets de Problemas, são diretamente do material original da Harvard (CS50 2021 - licença do CS50), garantindo que tenhamos acesso ao mesmo conhecimento dos alunos da universidade.

A experiência é aprimorada com o ambiente de desenvolvimento, conhecido como IDE, que agora conta com Inteligência Artificial. Isso significa que podemos programar sem a necessidade de instalar qualquer software. O curso também oferece um servidor no Discord e um fórum no Discourse para facilitar a interação e discussão entre os participantes.

Ao finalizar o curso, podemos obter um certificado pela Fundação Estudar. Uma novidade emocionante é a disponibilidade de legendas em português, proporcionando uma ótima oportunidade para aprender e praticar inglês.

O CC50 é mais do que um curso, é uma experiência que nos desafia, expande nossa visão sobre problemas do mundo real e nos prepara para diversos caminhos profissionais. É como ter Harvard no Brasil, e estou ansioso para explorar todas as oportunidades que esse curso incrível oferece!

## Tecnologias
<div>
  <img src="https://img.shields.io/badge/Developer-239120?style=for-the-badge&logo=c&logoColor=white">
</div>

## Índice

- [Instrutores](#instrutor)
- [Apresentação](#apresentacao)
- [Modulo 00 Scratch](#modulo00)
- [Modulo 01 C](#modulo01)
- [Modulo 02 Arrays](#modulo02)
- [Modulo 03 Algoritmos](#modulo03)
- [Modulo 04 Memória](#modulo04)
- [Modulo 05 Estruturas de Dados](#modulo05)
- [Modulo 06 Python](#modulo06)
- [Modulo 07 SQL](#modulo07)
- [Modulo 08 HTML CSS JavaScript](#modulo08)
- [Modulo 09 Flask](#modulo09)
- [Modulo 10 Etica](#modulo10)
- [Encerramento do Curso](#encerramento)
- [Licença](#licença)

## <a name="instrutor"> Instrutores </a>

- [David J. Malan](https://cs.harvard.edu/malan/) - Professor de Ciência da Computação em Harvard
- [Brian Yu](https://cs.harvard.edu/malan/) - Instrutor de Ciência da Computação em Harvard
- [Doug Lloyd](https://cs.harvard.edu/malan/) - Instrutor de Ciência da Computação em Harvard

## <a name="apresentacao"> Apresentação </a>

O curso CC50 é uma versão do curso CS50, que é o curso introdutório de Ciência da Computação de Harvard, que está repleto de conteúdo e novidades incríveis! Esse curso renomado mundialmente oferece uma sólida base em computação, Internet, programação e muito mais, tudo de forma gratuita.
Durante o curso, exploramos o funcionamento de computadores, a Internet e desenvolvemos habilidades em programação. Ao término, estaremos prontos para iniciar projetos em áreas como Web Design, Bancos de Dados, Sistemas Eletrônicos e Programação de Software. Apesar de desafiador, o curso é acessível a todos, independentemente da experiência em programação.
O professor David J. Malan utiliza uma didática incrível, tornando o aprendizado ainda mais enriquecedor. Todos os materiais, incluindo a tradução das aulas e dos Sets de Problemas, são diretamente do material original da Harvard (CS50 2021 - licença do CS50), garantindo que tenhamos acesso ao mesmo conhecimento dos alunos da universidade.
A experiência é aprimorada com o ambiente de desenvolvimento, conhecido como IDE, que agora conta com Inteligência Artificial. Isso significa que podemos programar sem a necessidade de instalar qualquer software. O curso também oferece um servidor no Discord e um fórum no Discourse para facilitar a interação e discussão entre os participantes.
Ao finalizar o curso, podemos obter um certificado pela Fundação Estudar. Uma novidade emocionante é a disponibilidade de legendas em português, proporcionando uma ótima oportunidade para aprender e praticar inglês.
O CC50 é mais do que um curso, é uma experiência que nos desafia, expande nossa visão sobre problemas do mundo real e nos prepara para diversos caminhos profissionais. É como ter Harvard no Brasil, e estou ansioso para explorar todas as oportunidades que esse curso incrível oferece!

## <a name="modulo00"> Modulo 00 Scratch </a>

Aula 0- Conheça o Scratch

[![Aula 0- Conheça o Scratch](img/00-Aula00_youtube.png)](https://www.youtube.com/watch?v=9iPsnGJ3kVE&t)

Na aula 0, exploramos diversos tópicos essenciais da Ciência da Computação. Começamos com uma calorosa recepção e uma introdução ao curso, abordando conceitos como representação numérica, algoritmos, pseudocódigo e outras fundamentais da disciplina.
  
A discussão sobre representação numérica incluiu sistemas como unário, decimal e binário, este último sendo o utilizado pelos computadores. A compreensão de como números são representados é crucial para entender o funcionamento interno dos dispositivos eletrônicos.
  
Exploramos também a representação de texto através de códigos como ASCII e Unicode, que mapeiam números para caracteres, possibilitando a exibição de letras, números e símbolos em computadores. Além disso, discutimos como imagens, vídeos e sons são representados por bits, permitindo a criação e reprodução de conteúdo visual e auditivo.
  
O conceito de algoritmos foi introduzido como uma abordagem sistemática para resolver problemas. Analisamos a eficiência de diferentes algoritmos, destacando a importância de projetar soluções que sejam não apenas corretas, mas também eficientes em termos de tempo de execução.
  
O pseudocódigo foi apresentado como uma ferramenta para descrever algoritmos em uma linguagem próxima do inglês, facilitando a compreensão e o planejamento de soluções. Observamos como as funções, condições, expressões booleanas e loops são elementos essenciais na criação de algoritmos estruturados.
  
Em resumo, esta aula inaugural proporcionou uma visão abrangente dos conceitos fundamentais da Ciência da Computação, estabelecendo as bases para explorarmos temas mais avançados ao longo do curso. Estou empolgado para continuar aprendendo e aplicando esses conhecimentos na prática!

<details>
  <summary>Mais detalhes Scratch</summary>
  Agora, ao explorar o Scratch, começamos a criar programas utilizando blocos de construção como funções, condições, expressões booleanas e rotações. Ao contrário da linguagem de programação baseada em texto C, o Scratch utiliza uma abordagem gráfica, permitindo-nos arrastar e soltar blocos que contêm instruções.
  
  No ambiente do Scratch, compreendemos a estrutura, onde temos um palco para exibir o programa, peças de quebra-cabeça representando funções ou variáveis, e a possibilidade de adicionar personagens. Experimentamos a criação de programas simples, como fazer o gato dizer "olá, mundo", utilizando blocos como "say" e "green flag clicked".
  
  Exploramos a extensão "text-to-speech", que converte texto em áudio, e experimentamos com a criação de programas mais complexos, como fazer o gato miar ou desenhar quando o mouse é clicado. Introduzimos conceitos como variáveis, loops, e extensões como "Translate" para tradução de idiomas.
  
  Ao observar demos como Gingerbread tales remix e Oscartime, percebemos a importância do design e da abstração para criar programas mais legíveis e eficientes. Concluímos com a compreensão de que as habilidades adquiridas no curso, como resolução de problemas e algoritmos, têm aplicações além da ciência da computação.
</details>

<details>
  <summary>Mais detalhes exercício:</summary>
  Agora é a minha vez de escolher uma aventura no Scratch! A tarefa é criar um projeto à minha escolha, seja uma história interativa, jogo, animação, ou qualquer outra coisa. Existem alguns requisitos a seguir:
  
  O projeto deve ter pelo menos dois sprites, sendo que um deles não deve ser um gato.
  Preciso criar pelo menos três scripts no total, distribuídos entre os sprites.
  Uso de pelo menos uma condição no projeto.
  Implementação de pelo menos um loop.
  Utilização de pelo menos uma variável.
  Inclusão de pelo menos um som no projeto.
  O projeto deve ser mais complexo do que a maioria apresentada nas aulas, mas não necessariamente tão complexo quanto o Ivy’s Hardest Game.
  Para me inspirar, posso explorar projetos de alunos anteriores ou tutoriais no Scratch. No entanto, é encorajado que eu pense em uma ideia própria antes de começar a implementá-la. A estratégia é avançar passo a passo, escrevendo pequenos trechos de código, testando, e repetindo o processo. A cada poucos minutos, devo salvar meu trabalho para não perder nada.
  
  Se encontrar dificuldades, posso ajustar o design ou contornar o problema. O importante é me divertir ao implementar uma ideia que eu ache interessante. Ao concluir o projeto, devo salvar e compartilhar o arquivo para mostrar aos colegas e familiares. Estou pronto para a aventura no Scratch!

</details>

Explorando a Selva Criativa do Scratch: O Desafio do Dinossauro Google!

Recentemente, aventurei-me na selva criativa do Scratch, enfrentando o desafio de criar um projeto envolvente e único. Escolhi como meu campo de experimentação a recriação do lendário Dinossauro do Google, aquela simpática criatura pré-histórica que pula sobre obstáculos quando a conexão de internet se perde.

O coração do meu projeto pulsou seguindo as diretrizes propostas, adicionando camadas de complexidade e diversão. Com pelo menos dois sprites em cena, meu mundo ganhou vida com um dinossauro como protagonista e um cenário repleto de desafios. Criar três scripts, cada um uma sinfonia de comandos e ações, proporcionou um toque especial à experiência do jogador.

Ao adentrar na selva do Scratch, as condições se tornaram o terreno onde a diversão se desenrolava. Estabelecer regras de jogo, determinando quando o dinossauro deveria saltar ou abaixar, deu um toque estratégico ao meu projeto. A introdução de loops permitiu que o dinossauro enfrentasse uma série de desafios em movimento contínuo, mantendo os jogadores em suspense.

A criatividade floresceu com a introdução de variáveis, elementos dinâmicos que deram vida ao jogo. A cada salto e esquiva, as variáveis registravam pontos e desencadeavam eventos especiais, tornando a experiência interativa e envolvente.

Apesar de não incorporar sons no projeto, a atmosfera do jogo permanece intensa. Cada pulo do dinossauro, cada vitória e derrota são marcados por uma trilha sonora imaginativa, criada mentalmente durante a exploração da selva virtual.

A combinação desse esforço criativo encontra-se no meu projeto do Dinossauro Google, agora disponível para explorar e desfrutar [aqui](https://scratch.mit.edu/projects/971443808). Cada linha de código é um fragmento do meu entusiasmo, cada comando uma escolha deliberada para criar uma experiência única. Sinta-se convidado a aventurar-se na terra dos dinossauros, onde a diversão é infinita, e a criatividade não conhece limites!

![](img/01-scratch-dinossauro.png)

Link para o projeto: [Dinossauro Google](https://scratch.mit.edu/projects/971443808)

## <a name="modulo01"> Modulo 01 C </a>

Aula 1- Linguagem de Programação C

[![Aula 1- Linguagem de Programação C](img/02-Aula01_youtube.png)](https://www.youtube.com/watch?v=rCTePooJP_s)


Hoje dei início ao Módulo 1 do curso CC50. Na segunda aula, fui introduzido à linguagem de programação C e aprendi sobre conceitos como compilação, funções, argumentos, ferramentas e comandos, tipos e formatos de código. Conheci a IDE do curso e explorei os conceitos de operadores, limitações, truncamentos, estruturas condicionais, repetição, expressões booleanas, abstração, header de arquivos, função main, memória e overflow.

Durante a aula, discutimos tópicos como a linguagem C, CS50 IDE, compilação, funções e argumentos, ferramentas, comandos, tipos e códigos de formato, operadores, limitações, truncamento, variáveis, açúcar sintático, condicionais, expressões booleanas, loops, abstração, memória, imprecisão e overflow.

Em seguida, exploramos um exemplo de código em C, onde aprendi a estrutura básica de um programa nessa linguagem:
  
  ```c
  #include <stdio.h>
  int main(void) 
    {
        printf("olá, mundo"); 
    }
  ```
Mesmo que inicialmente absorver esses novos conceitos pareça desafiador, acredito que ao longo do semestre me tornarei mais capacitado e experiente na aplicação desses conhecimentos. Fiz algumas anotações sobre as principais ideias, como correção, design e estilo na programação.

Utilizando a CS50 IDE, uma plataforma baseada em nuvem, pude escrever e compilar meu código em C. A compilação foi necessária porque os computadores entendem apenas linguagem binária, e o código fonte em C precisa ser convertido para essa forma. Utilizei comandos como make hello para compilar e ./hello para executar meu programa.

Exploramos também o conceito de funções e argumentos em C, comparando-os aos blocos do Scratch. Aprendi sobre a função printf e a importância de bibliotecas, como a Biblioteca CS50, que fornece funções prontas para uso, como get_string. Adaptei o código para solicitar o nome do usuário e imprimir uma saudação personalizada.

Além disso, compreendi a importância da função main e dos arquivos de cabeçalho (.h) em C, assim como a necessidade de ferramentas como help50, style50 e check50 para auxiliar na escrita e verificação do código.

Ao final da aula, comecei a sentir mais confiança na utilização da linguagem C e na compreensão dos conceitos apresentados. Estou animado para continuar aprendendo e aplicando esses conhecimentos ao longo do curso. Caso surjam dúvidas, agora sei que posso compartilhá-las no fórum ou no Discord recomendados

Comandos e ferramentas em C:

Aprendi a utilizar comandos no terminal, manipular tipos de dados e códigos de formato, compreender operadores matemáticos, implementar estruturas condicionais e loops, além de abordar conceitos fundamentais de memória e imprecisão.

No ambiente virtual CS50 IDE, utilizei comandos como ls, rm, mv, mkdir, e cd para gerenciar arquivos e diretórios. Entendi a importância de tipos de dados como bool, char, double, float, int, long, e string, bem como as funções correspondentes da biblioteca CS50 para obter entrada de diversos tipos.

Exploramos operadores matemáticos como +, -, *, /, e %, e criei programas para realizar cálculos simples. Abordamos o conceito de truncamento ao lidar com operações de divisão entre inteiros e a importância de fazer casting para evitar perda de precisão.

Compreendi a prática de boas práticas de programação, como a utilização de açúcar sintático para incrementar variáveis e a necessidade de seguir convenções de estilo. Implementei estruturas condicionais (if, else if, else) para tomar decisões no código, utilizando operadores de comparação como ==, <, e >.

Aprendi sobre loops, utilizando while e for para criar iterações em programas. Entendi a importância da abstração, criando funções para organizar o código e facilitar a reutilização. Exploramos também a captura de entrada do usuário, a validação de dados e a implementação de loops aninhados para criar padrões de caracteres.

Além disso, discutimos questões relacionadas à memória, imprecisão em cálculos de ponto flutuante e problemas de estouro. Compreendi como os computadores armazenam dados na memória RAM e os desafios associados à representação de números reais com precisão finita.

Ao longo do curso, desenvolvi programas simples e compreendi conceitos fundamentais da linguagem de programação C, preparando-me para explorar tópicos mais avançados nesta jornada de aprendizado.

<details>
  <summary>Mais detalhes exercício Mario/less:</summary>
  Já completei o exercício 1, conhecido como "Mario (versão fácil)", durante o curso. Neste desafio, desenvolvi um programa em C chamado mario.c que recria uma pirâmide de blocos, semelhante à encontrada no jogo Super Mario Brothers da Nintendo, utilizando hashtags (#). Cada hashtag é um pouco mais alto do que largo, proporcionando uma forma piramidal.
  
  O código foi estruturado no diretório [Modulo-01-C/02_mario/mario.c](Modulo-01-C/02_mario/mario.c).. O programa permite que o usuário escolha a altura da pirâmide, solicitando um número inteiro positivo entre 1 e 8, inclusive.
  
  Realizei testes para verificar o funcionamento do programa com diferentes alturas inseridas pelo usuário. Caso o usuário insira um valor inválido (menor que 1, maior que 8 ou não inteiro), o programa solicita uma nova entrada até receber um valor válido.
  
  O pseudocódigo para o exercício foi adicionado ao arquivo [pseudocodigo.txt](Modulo-01-C/02_mario/pseudocodigo.txt) no diretório mario. Este pseudocódigo descreve de forma geral os passos necessários para implementar o programa, destacando a solicitação de altura, a validação da entrada e a iteração para imprimir a pirâmide de hashtags. Este spoiler é apenas uma abordagem para a resolução do exercício, e existem diversas maneiras de implementar o código em C.
  
  Link do teste: [Teste CS50 Mario](https://submit.cs50.io/check50/6d26e9218d295f092e635070e2b95a08eded654a)
</details>

<details>
  <summary>Mais detalhes exercício Mario/more:</summary>
  Já concluí o exercício 2, conhecido como "Mario", durante o curso. Nesse desafio, desenvolvi um programa em C chamado mario.c. A proposta era recriar pirâmides de blocos, semelhantes às encontradas no jogo Super Mario Brothers, utilizando hashtags (#) para representar os tijolos. A altura das pirâmides foi definida pelo usuário, que inseriu um número inteiro positivo entre 1 e 8, inclusivamente.

  O código foi estruturado no diretório [Modulo-01-C/03_mario/mario.c](Modulo-01-C/03_mario/mario.c). Realizei testes para garantir que o programa atendesse a diversos casos de entrada, incluindo números negativos, zero, números de 1 a 8, números maiores que 8, entrada de letras ou palavras, e até mesmo a situação em que nenhum valor é inserido (apenas pressionando Enter).
  
  A "lacuna" entre as pirâmides adjacentes sempre possui a largura de dois hashes, independentemente da altura das pirâmides. Ao finalizar, segui as instruções para testar o código no IDE do CS50, verificando se todas as condições do exercício foram cumpridas, como a correta manipulação de entradas inválidas.
  
  Link do teste: [Teste CS50 Mario](https://submit.cs50.io/check50/90c3744a6e0e7da933006f07e9e7f3c7691eaaa6)
</details>

<details>
  <summary>Mais detalhes exercício Dinheiro:</summary>
  Depois de completar este exercício, entendi a aplicação de algoritmos gananciosos ou ambiciosos ao lidar com situações práticas, como dar troco. A ideia principal é minimizar o número de moedas distribuídas, garantindo eficiência e evitando esgotamento do estoque.
  
  O algoritmo ganancioso escolhe a melhor solução local imediatamente, mesmo que possa não ser a melhor em todos os casos. Por exemplo, ao dar troco usando moedas de 25, 10, 5 e 1 centavo, o algoritmo escolhe a moeda de maior valor possível para cada "mordida". Isso é feito para otimizar a eficiência, reduzindo o problema inicial a problemas menores e mais simples.
  
  A implementação prática desse conceito envolve criar um programa em C chamado cash.c. Este programa pede ao usuário o valor do troco devido, usando get_float para lidar com reais e centavos. O objetivo é imprimir o número mínimo de moedas necessário para o troco, assumindo disponibilidade ilimitada de moedas de 25, 10, 5 e 1 centavo.
  
  O cuidado com a imprecisão dos valores de ponto flutuante é destacado, recomendando a conversão dos valores inseridos pelo usuário em centavos para evitar erros acumulativos. Além disso, o programa deve arredondar os centavos até o último centavo mais próximo usando a função round da biblioteca math.h.
  
  O programa deve lidar com entradas não negativas e solicitar novamente se o usuário fornecer uma quantia inválida. A saída do programa deve ser apenas o número mínimo de moedas, seguido por uma quebra de linha.
  
  Ao finalizar esse exercício, meu entendimento prático sobre algoritmos gananciosos e a aplicação desses conceitos foi solidificado. Agora estou mais confortável em abordar desafios práticos usando essas estratégias.  
  O código foi estruturado no diretório [Modulo-01-C/04_dinheiro/cash.c](Modulo-01-C/04_dinheiro/cash.c).
  
  Link do teste: [Teste CS50 Dinheiro](https://submit.cs50.io/check50/a2014536da2084705556280c9be7e77b6a7799a8)
</details>

<details>
  <summary>Mais detalhes exercício Credit:</summary>
  Já concluí o exercício sobre validação de números de cartão de crédito, compreendendo o funcionamento do algoritmo de Luhn e sua aplicação prática. Agora, sou capaz de explicar como determinar a validade de um número de cartão de crédito usando um programa em C chamado credit.c.
  
  Primeiramente, é essencial entender que os números de cartão de crédito possuem uma estrutura específica, com alguns dígitos iniciais distintos para diferentes empresas. Além disso, eles obedecem ao algoritmo de Luhn, um método inventado por Hans Peter Luhn da IBM, que permite verificar a sintaxe de um número de cartão de crédito.
  
  O algoritmo de Luhn consiste nos seguintes passos:

  - Multiplicar cada segundo dígito por 2, começando com o penúltimo dígito do número, e somar os dígitos - desses produtos.
  - Adicionar essa soma à soma dos dígitos que não foram multiplicados por 2.
  - Se o último dígito do total for 0 (módulo total 10 congruente com 0), o número é considerado válido.

  A implementação prática desse algoritmo envolve escrever um programa em C que solicita ao usuário um número de cartão de crédito, usando get_long para lidar com números longos. O programa então verifica se o número fornecido é um cartão American Express, MasterCard ou Visa válido, seguindo as definições de formato de cada um.
  
  A última linha de saída do programa deve ser AMEX, MASTERCARD, VISA ou INVALID, dependendo do resultado da verificação. É importante lidar com entradas não numéricas e garantir que o usuário forneça um número válido.
  
  Após testar o programa com diversas entradas, tanto válidas quanto inválidas, e corrigir possíveis problemas, estou confiante em minha capacidade de implementar e entender algoritmos práticos em C.

  O código foi estruturado no diretório [Modulo-01-C/05_credit/credit.c](Modulo-01-C/05_credit/credit.c).
  
  Link do teste: [Teste CS50 Credit](https://submit.cs50.io/check50/1c9fa4bd6c64fc84fcb084862c8cf7fd3b815a7a)
</details>

<details>
  <summary>Mais detalhes Laboratório 1 - Crescimento populacional:</summary>
  Concluí o Laboratório 1 sobre crescimento populacional, onde aprendi a calcular o tempo necessário para uma população atingir um determinado tamanho usando programação em C.
  
  Inicialmente, copiei o código fornecido para um novo arquivo chamado population.c no meu IDE. Este código serve como ponto de partida para o desenvolvimento do programa.
  
  O objetivo era solicitar ao usuário o tamanho inicial e final da população e calcular o número de anos necessários para atingir o tamanho final, considerando um modelo de crescimento populacional específico. Neste modelo, a cada ano nascem n/3 novos indivíduos e n/4 morrem.
  
  Implementei o código para solicitar o tamanho inicial e final da população, garantindo que fossem inseridos valores válidos. Se o usuário inserisse valores inválidos, o programa o instruiria a fornecer valores dentro dos limites permitidos.
  
  Utilizei loops do...while para garantir a entrada adequada do usuário. Além disso, empreguei uma variável para controlar o número de anos e atualizei o tamanho da população conforme a fórmula específica do modelo.
  
  Ao final, o programa imprime o número de anos necessário para a população atingir o tamanho final no formato "Years: n".
  
  Testei o código com diversos casos, incluindo diferentes tamanhos iniciais e finais da população. O programa mostrou-se eficaz ao lidar com entradas válidas e inválidas, proporcionando resultados precisos. Este laboratório consolidou minha compreensão sobre loops, condicionais e entrada de dados em C.

  O código foi estruturado no diretório [Modulo-01-C/06_population/population.c](Modulo-01-C/06_population/population.c).
  
  Link do teste: [Teste CS50 Crescimento populacional](https://submit.cs50.io/check50/a877a9104b3974f35df73d61c09ce1cbea0a597b)
</details>

## <a name="modulo02"> Modulo 02 Arrays </a>

Aula 2- Arrays

[![Aula 2- Arrays](img/03-Aula02_youtube.png)](https://www.youtube.com/watch?v=yvAVgpKW6tY)

Minha experiência na aula de Arrays foi bastante informativa e prática. Durante a segunda aula, focamos em diversos tópicos, como compilação, depuração, memória, matrizes, strings, argumentos de linha de comando e formulários.

Na compilação, aprendemos a transformar nosso código-fonte em código de máquina utilizando o compilador clang. Utilizando o comando make, que na verdade invoca o clang, conseguimos compilar nossos programas e gerar arquivos executáveis. Além disso, exploramos a importância da pré-compilação, compilação, montagem e vinculação na transformação do código-fonte em código executável.

No tópico de depuração, abordamos a identificação e correção de bugs em nossos programas. Utilizando ferramentas como help50, style50 e check50, aprendemos a melhorar a qualidade e correção do nosso código. Também exploramos o uso da função printf como uma ferramenta de depuração, adicionando mensagens temporárias para entender melhor o fluxo do programa.

Ao discutir memória, compreendemos os diferentes tipos de variáveis em C e sua alocação na memória RAM. Exploramos conceitos como bytes, bits e o uso de variáveis como bool, char, int, double, float, e string, cada uma ocupando uma quantidade específica de espaço na memória.

No tópico de matrizes, aprendemos a declarar e manipular arrays, armazenando múltiplos valores do mesmo tipo em uma única variável. Com exemplos práticos, como calcular a média de valores em um array, entendemos como iterar sobre os elementos usando loops.

Strings foram discutidas como arrays de caracteres, onde cada caractere é armazenado em uma posição específica da memória. Exploramos a manipulação de strings, conversão de caracteres para seus valores ASCII e o uso de funções como strlen, islower, toupper para processar e modificar strings de maneira eficiente.

Os argumentos de linha de comando foram introduzidos como uma forma de fornecer inputs para nossos programas ao executá-los a partir da linha de comando. Entendemos como argc e argv são usados para receber esses argumentos e adaptamos nosso programa para responder de acordo.

Finalmente, discutimos aplicações práticas, como analisar a legibilidade de parágrafos de texto e exploramos conceitos iniciais sobre criptografia, onde entendemos a ideia de cifras, plaintext, ciphertext e a importância de chaves secretas.

Essa aula proporcionou uma compreensão mais aprofundada dos fundamentos da programação em C, preparando-me para enfrentar desafios mais complexos no desenvolvimento de software.

<details>
  <summary>Mais detalhes exercício Legibilidade:</summary>
  Após concluir o curso, desenvolvi um programa chamado "readability" que calcula o índice Coleman-Liau de um texto para determinar seu nível de leitura aproximado. O programa solicita ao usuário uma string de texto, conta o número de letras, palavras e frases no texto e, em seguida, utiliza a fórmula Coleman-Liau para calcular o nível de leitura.
  
  Ao executar o programa, o usuário insere um texto, e o programa fornece como saída o resultado no formato "Grade X", onde X representa o nível de grau calculado. Se o índice resultante for 16 ou superior, indicando um nível de leitura equivalente ou superior ao de um graduado sênior, o programa exibe "Grade 16+". Se o índice for inferior a 1, o programa imprime "Before Grade 1".
  
  Ao longo do desenvolvimento, utilizei a fórmula Coleman-Liau, que é expressa por índice = 0,0588 * L - 0,296 * S - 15,8, onde L é o número médio de letras por 100 palavras no texto e S é o número médio de sentenças por 100 palavras no texto.
  
  Para exemplificar, ao inserir um trecho do Dr. Seuss, o programa calcula o nível de leitura com base nas médias de letras e sentenças por 100 palavras, conforme a fórmula mencionada anteriormente. Dessa forma, proporciona uma avaliação compreensível do nível de leitura do texto, em um formato amigável, como "Grade 3". Este método também foi aplicado a outros textos de exemplo para verificar a consistência e eficácia do programa. 

  O código foi estruturado no diretório [Modulo-02-Arrays/07_readability/readability.c](Modulo-02-Arrays/07_readability/readability.c).O programa foi testado com diversos casos, incluindo exemplos com diferentes complexidades textuais, para garantir que funcionasse conforme as especificações do problema.
  
  Link do teste: [Teste CS50 Legibilidade](https://submit.cs50.io/check50/2fc7d5e283d448109d174493795397a226297f24)
</details>

<details>
  <summary>Mais detalhes exercício Caesar:</summary>
  Após concluir o curso, desenvolvi um programa chamado "caesar" que implementa a cifra de César para criptografar mensagens. A cifra de César é um método de criptografia que envolve o deslocamento de cada letra em um número fixo de posições no alfabeto. O programa aceita um único argumento de linha de comando, representando a chave de criptografia.
  
  Ao ser executado, o programa verifica se o argumento da linha de comando é um número não negativo e exibe uma mensagem de erro caso contrário. Em seguida, solicita ao usuário inserir o texto simples e, para cada caractere do texto, realiza o deslocamento conforme a cifra de César, preservando a capitalização e ignorando caracteres não alfabéticos. O resultado criptografado é exibido como saída, seguido por uma nova linha.
  
  O código fonte foi implementado em um arquivo chamado "caesar.c" dentro do diretório "caesar". O programa foi projetado para garantir a segurança e coerência da criptografia, mesmo que o usuário forneça uma chave maior que 26. Caso o programa seja executado sem argumento ou com mais de um argumento, uma mensagem de erro adequada é exibida.
  
  O pseudocódigo básico para o programa envolve a verificação do argumento de linha de comando, a conversão da chave para um número inteiro, a solicitação do texto simples e a aplicação da cifra de César a cada caractere do texto. 
  
  O código foi estruturado no diretório [Modulo-02-Arrays/08_caesar/caesar.c](Modulo-02-Arrays/08_caesar/caesar.c).O programa foi testado com vários casos, incluindo exemplos com diferentes chaves e textos simples para garantir seu funcionamento conforme as especificações do problema.
  
  Link do teste: [Teste CS50 Caesar](https://submit.cs50.io/check50/1e7246bb66c1e0b9379f54193cd6d6ad28765609)
</details>

<details>
  <summary>Mais detalhes exercício Substituição:</summary>
  Após concluir o curso, desenvolvi um programa chamado "substitution" que implementa uma cifra de substituição para criptografar mensagens. Nessa cifra, cada letra é substituída por outra de acordo com uma chave fornecida pelo usuário. A chave é uma sequência de 26 caracteres que mapeia cada letra do alfabeto para a letra correspondente na cifra.
  
  Ao ser executado, o programa verifica se o usuário forneceu um único argumento de linha de comando, representando a chave de substituição. Em seguida, verifica se a chave é válida, garantindo que contenha exatamente 26 caracteres alfabéticos e que cada letra apareça apenas uma vez. Caso contrário, exibe uma mensagem de erro apropriada e encerra o programa.
  
  O programa solicita ao usuário inserir o texto simples e, para cada caractere do texto, realiza a substituição de acordo com a chave. O resultado criptografado é exibido como saída, preservando a capitalização e ignorando caracteres não alfabéticos. Após a saída do texto cifrado, o programa imprime uma nova linha e retorna 0 da função main.
  
  O programa foi projetado para garantir a validade da chave de substituição e preservar a capitalização das letras maiúsculas e minúsculas no texto original.
  
  O pseudocódigo básico para o programa envolve a verificação do argumento de linha de comando, a validação da chave, a solicitação do texto simples e a aplicação da cifra de substituição a cada caractere do texto.
  
  O código foi estruturado no diretório [Modulo-02-Arrays/09_substitution/substitution.c](Modulo-02-Arrays/09_substitution/substitution.c).O programa foi testado com vários casos, incluindo exemplos com diferentes chaves e textos simples, para garantir seu funcionamento conforme as especificações do problema.
  
  Link do teste: [Teste CS50 Substituição](https://submit.cs50.io/check50/57da596dab1558fafd74c95f10952526d595575e)
</details>

<details>
  <summary>Mais detalhes Laboratório 2 - Scrabble:</summary>
  Após concluir o curso, eu desenvolvi um programa chamado "scrabble.c", que determina o vencedor em um jogo curto de Scrabble. Neste jogo, dois jogadores inserem suas palavras, e o programa calcula a pontuação de cada palavra com base nos valores atribuídos a cada letra do alfabeto.
  
  O programa utiliza uma matriz chamada POINTS, onde cada posição representa a pontuação associada a uma letra específica. Por exemplo, A ou a valem 1 ponto (POINTS[0]), B ou b valem 3 pontos (POINTS[1]), e assim por diante.
  
  Ao executar o programa, os jogadores inserem suas palavras, que são armazenadas nas variáveis word1 e word2. O programa então utiliza a função compute_score() para calcular a pontuação de cada palavra, considerando os valores da matriz POINTS.
  
  A função compute_score() recebe uma string como argumento e retorna a pontuação total da palavra, atribuindo zero pontos a caracteres que não são letras. As letras maiúsculas e minúsculas recebem os mesmos valores de pontos.
  
  No final, o programa imprime "Player 1 wins!", "Player 2 wins!", ou "Tie!" dependendo das pontuações dos jogadores.
  
  O código foi estruturado no diretório [Modulo-02-Arrays/10_scrabble/scrabble.c](Modulo-02-Arrays/10_scrabble/scrabble.c).O código foi testado com diferentes casos, garantindo que o programa funcione corretamente e forneça os resultados esperados para diversas situações, conforme indicado nos exemplos de teste fornecidos.
  
  Link do teste: [Teste CS50 Scrabble](https://submit.cs50.io/check50/782fa90e0518fe9860876d58d82058905db6ff85)
</details>

## <a name="modulo03"> Modulo 03 Algoritmos </a>

Aula 3- Algoritmos

[![Aula 3- Algoritmos](img/04-Aula03_youtube.png)](https://www.youtube.com/watch?v=oBOTNWx0EzY)

Ao revisar as anotações da aula de Algoritmos, pude aprofundar meu entendimento sobre diversos conceitos importantes. A aula começou com uma revisão do módulo anterior, onde aprendemos sobre ferramentas para solucionar problemas no código, como o uso de depuradores e a técnica de "duck debugging".

A parte principal da aula abordou o tema de buscas em algoritmos. A busca, seja linear ou binária, é fundamental para encontrar valores específicos em uma coleção de dados. A notação Big O foi introduzida para descrever o tempo de execução dos algoritmos em diferentes situações. Além disso, foram discutidos algoritmos de ordenação, como o selection sort e bubble sort, cada um com seu próprio desempenho em termos de tempo de execução.

A aula também cobriu o conceito de structs em programação em C, permitindo a criação de estruturas de dados personalizadas. Essa parte foi exemplificada com a implementação de uma lista telefônica, mostrando como structs podem melhorar a organização do código.

Outro tópico importante foi a recursão, que é a capacidade de uma função chamar a si mesma. Isso foi exemplificado por meio de uma abordagem recursiva para desenhar uma pirâmide de blocos.

Por fim, a aula introduziu o algoritmo de ordenação merge sort, que utiliza a recursão para dividir e mesclar listas, proporcionando uma abordagem eficiente para a ordenação.

Em resumo, a aula de Algoritmos forneceu uma compreensão mais profunda de conceitos como busca, ordenação, structs, recursão e algoritmos de ordenação específicos. Este conhecimento aprimorado será valioso para resolver problemas complexos e otimizar o desempenho dos programas que desenvolvo.

<details>
  <summary>Mais detalhes exercício Plurality:</summary>
  Eu já fiz o curso e entendi o que está acontecendo aqui. Estamos lidando com um exercício de programação onde precisamos implementar um programa em C que simule uma eleição de pluralidade. Basicamente, trata-se de um sistema de votação onde cada eleitor pode votar em apenas um candidato, e o candidato com o maior número de votos vence a eleição.

  O programa começa pedindo ao usuário que insira os nomes dos candidatos através da linha de comando. Em seguida, solicita o número de eleitores e permite que cada eleitor vote em um candidato.

  O código fornecido já possui algumas estruturas básicas, como a definição de uma estrutura candidate para representar cada candidato, e uma matriz global de candidates para armazenar todos os candidatos.

  No entanto, há duas funções principais, vote e print_winner, que precisam ser completadas para que o programa funcione corretamente.

  A função vote recebe o nome de um candidato como entrada e deve atualizar o número de votos desse candidato, se o nome corresponder a um candidato válido. Se o nome não corresponder a nenhum dos candidatos na eleição, a função retorna falso para indicar uma cédula inválida.

  Já a função print_winner deve imprimir o nome do candidato que recebeu mais votos na eleição. Em caso de empate, deve imprimir os nomes de todos os candidatos vencedores.

  Para testar o programa, podemos usar exemplos como os fornecidos nas especificações. O código foi estruturado no diretório [Modulo-03-Algoritmos/11_plurality/plurality.c](Modulo-03-Algoritmos/11_plurality/plurality.c). Podemos inserir os nomes dos candidatos e simular a votação de um número específico de eleitores. Em seguida, o programa deve imprimir o nome do vencedor ou vencedores, conforme necessário.
  
  Link do teste: [Teste CS50 Plurality](https://submit.cs50.io/check50/96b7b0a8c81909658d9159f70a6deb87b4756718)
</details>

<details>
  <summary>Mais detalhes exercício Runoff:</summary>
  
  Neste exercício, estamos simulando uma eleição de segundo turno, onde os eleitores podem classificar os candidatos em ordem de preferência. O objetivo é implementar um programa chamado "runoff" que execute esse processo.

  Em uma eleição de segundo turno, cada eleitor classifica os candidatos em ordem de preferência. Em vez de apenas escolher um candidato, eles podem indicar sua primeira, segunda e terceira escolhas. Isso permite uma representação mais precisa das preferências dos eleitores.

  No programa fornecido, há uma série de funções a serem implementadas para simular o processo eleitoral:

  vote: Esta função registra o voto de um eleitor, indicando a preferência deles entre os candidatos.

  tabulate: Atualiza o número de votos que cada candidato recebeu até o momento.

  print_winner: Verifica se algum candidato já obteve a maioria dos votos e imprime o vencedor, se aplicável.

  find_min: Determina o menor número de votos que qualquer candidato ainda na eleição possui atualmente.

  is_tie: Verifica se há um empate entre todos os candidatos restantes.

  eliminate: Elimina o candidato (ou candidatos) com o menor número de votos.

  O processo de votação continua até que um candidato obtenha a maioria dos votos ou até que ocorra um empate entre todos os candidatos restantes. Em caso de empate, a eleição é declarada empatada.

  Para testar o programa, podemos usar exemplos como os fornecidos nas especificações. O código foi estruturado no diretório [Modulo-03-Algoritmos/12_runoff/runoff.c](Modulo-03-Algoritmos/12_runoff/runoff.c). Devemos garantir que funcione corretamente para diferentes números de candidatos, que os votos sejam registrados corretamente, que candidatos inválidos não sejam considerados e que o vencedor seja impresso corretamente. Também precisamos verificar se o programa lida corretamente com empates entre todos os candidatos restantes, sem eliminar ninguém nesse caso.
  
  Link do teste: [Teste CS50 Runoff](https://submit.cs50.io/check50/5a0817d65c51ff25a38f557c31a3cbcad55fb560)
</details>

<details>
  <summary>Mais detalhes exercício Tideman:</summary>
  Precisamos implementar um programa que simule uma eleição Tideman, também conhecida como eleição de pares ranqueados. Nesse tipo de eleição, os eleitores classificam os candidatos em ordem de preferência e, com base nessas classificações, determinamos o vencedor.

  Para entender melhor como funciona esse tipo de eleição, vamos considerar um exemplo. Suponha que temos três candidatos: Alice, Bob e Charlie. Em vez de simplesmente escolher um candidato, os eleitores os classificam. Por exemplo, um eleitor pode classificar Alice como sua primeira preferência, seguida por Charlie e depois Bob.

  Ao coletar os votos de todos os eleitores, podemos construir uma matriz de preferências, onde preferences[i][j] representa o número de eleitores que preferem o candidato i ao candidato j. Com base nessas preferências, podemos determinar os pares de candidatos onde um é preferido sobre o outro.

  Em seguida, classificamos esses pares em ordem decrescente de força de vitória, onde a força de vitória é o número de eleitores que preferem o candidato preferido. Depois disso, travamos esses pares no gráfico candidato, evitando criar ciclos. O candidato que não tem nenhuma aresta apontando para ele é declarado o vencedor da eleição.

  O programa já nos fornece um esqueleto para começar, com funções que precisamos implementar. Por exemplo, a função vote recebe as preferências de um eleitor e atualiza as classificações correspondentes. A função record_preferences atualiza a matriz de preferências com as preferências de cada eleitor. A função add_pairs adiciona os pares de candidatos preferidos, e assim por diante.

  Nossa tarefa é completar essas funções de acordo com as especificações fornecidas. Depois de implementar todas as funções necessárias, podemos testar o programa, podemos usar exemplos como os fornecidos nas especificações. O código foi estruturado no diretório [Modulo-03-Algoritmos/13_tideman/tideman.c](Modulo-03-Algoritmos/13_tideman/tideman.c), fornecendo o vencedor da eleição com base nos votos dados.
  
  Link do teste: [Teste CS50 Tideman](https://submit.cs50.io/check50/1189a000828c1dd25e86b9365a7e3d3d1b329fc2)
</details>

<details>
  <summary>Mais detalhes Laboratório 3 - Ordenação:</summary>
  No Laboratório de Classificação 3, minha tarefa é analisar três programas de classificação para determinar quais algoritmos eles estão usando. Na aula anterior, aprendemos sobre três algoritmos de classificação: selection sort, bubble sort e merge sort.

  O selection sort percorre a lista, selecionando o menor elemento a cada iteração e movendo-o para sua posição correta. O bubble sort compara pares de elementos adjacentes e os troca se estiverem fora de ordem, continuando até que a lista esteja ordenada. Por fim, o merge sort divide a lista em metades, classifica cada metade e, em seguida, mescla as metades ordenadas.

  Cada algoritmo tem sua própria eficiência, expressa em termos de tempo de execução, que varia dependendo do número e da ordem dos elementos na lista. Por exemplo, o selection sort e o bubble sort têm um tempo de execução de O(n^2), o que significa que pode levar um número quadrático de operações para classificar uma lista de tamanho n. Enquanto isso, o merge sort tem um tempo de execução de O(n log n), que é mais eficiente para listas maiores.

  Agora, minha missão é identificar qual algoritmo está por trás de cada programa de classificação (sort1, sort2 e sort3). Para isso, devo testar esses programas em diferentes arquivos de entrada contendo números em diferentes ordens (aleatória, invertida, classificada) e tamanhos. Usando o comando time, posso cronometrar quanto tempo cada programa leva para classificar os números.

  Por exemplo, executar o comando time ./sort1 reversed10000.txt me mostrará quanto tempo o sort1 leva para classificar 10.000 números invertidos. Ao observar o desempenho de cada programa em diferentes tipos de arquivos de entrada, posso deduzir qual algoritmo de classificação está sendo usado em cada caso.
  
  Registrarei minhas conclusões e explicações em [Modulo-03-Algoritmos/14_ordenacao/answers.txt](Modulo-03-Algoritmos/14_ordenacao/answers.txt). Analisando o comportamento de cada programa com base nos diferentes tipos de arquivos de entrada fornecidos. Ao considerar o desempenho de cada algoritmo com listas já classificadas, invertidas ou embaralhadas, poderei determinar qual algoritmo está associado a cada programa de classificação.
  
  Link do teste: [Teste CS50 Ordenação](https://submit.cs50.io/check50/7f9cf3f945e60d49f9230e2f8ee249eb17e6dadc)
</details>

## <a name="modulo04"> Modulo 04 Memória </a>

Aula 4 - Modulo 04 Memória

[![Aula 2- Arrays](img/05-Aula04_youtube.png)](https://www.youtube.com/watch?v=fprdsu0pvAg)

Durante o curso, aprendi sobre o sistema hexadecimal e como ele é fundamental para entender a organização da memória em computadores. Em vez de usar o sistema decimal convencional, os endereços de memória são expressos em hexadecimal, onde cada dígito representa um valor de 0 a 15.

Ao trabalhar com números hexadecimais de dois dígitos, percebi que eles podem representar valores de 0 a 255, que é o mesmo valor máximo representável por 8 bits em binário, tornando-os convenientes para representar bytes de dados. Além disso, aprendi sobre a notação de prefixo "0x" para indicar que um número está em hexadecimal, como em "0x10".

Explorando ainda mais o conceito de endereços de memória, descobri como os bytes de dados são armazenados em locais específicos na memória do computador. Ao utilizar ponteiros em C, pude acessar diretamente esses endereços e os valores armazenados neles. Os ponteiros, essencialmente, apontam para locais na memória onde os dados estão armazenados.

Um aspecto interessante que abordei foi o uso de ponteiros para strings. Descobri que uma string em C é na verdade um ponteiro para o primeiro caractere da string, e cada caractere subsequente está armazenado sequencialmente na memória. O caractere nulo '\0' indica o final da string.

Por meio de exemplos práticos e da exploração desses conceitos, pude entender como a memória é organizada e acessada em nível de byte, o que é fundamental para desenvolver programas eficientes e compreender melhor o funcionamento interno dos computadores.

Após concluir o curso de aritmética de ponteiros, ganhei um novo entendimento sobre como manipular dados em nível de memória, o que me permitiu melhorar minhas práticas de programação. 

Uma das primeiras coisas que aprendi foi sobre a aritmética de ponteiros, que envolve operações matemáticas em endereços de memória usando ponteiros. Com isso, pude compreender como acessar e manipular strings diretamente na memória, tanto imprimindo caracteres individuais quanto indo diretamente para os endereços de memória.

Além disso, aprendi sobre a importância de comparar e copiar dados corretamente. Por exemplo, ao comparar strings, percebi que mesmo que os caracteres fossem iguais, a comparação direta entre os ponteiros das strings resultaria em "Diferente". Isso me levou a entender a necessidade de fazer cópias seguras de strings para evitar problemas de acesso indevido à memória.

Aprofundando meu conhecimento, aprendi sobre o layout de memória em um computador e como diferentes seções da memória são organizadas para armazenar dados do programa. Isso me deu insights sobre problemas como vazamentos de memória e overflow de pilha e heap, e aprendi a usar ferramentas como Valgrind para detectá-los e corrigi-los.

Também ganhei experiência na manipulação de arquivos em C, desde a abertura e leitura de arquivos até a cópia de arquivos byte a byte. Isso expandiu minha capacidade de lidar com dados de entrada e saída em meus programas, permitindo-me trabalhar com diferentes tipos de arquivos, como CSV e imagens.

Por fim, explorei conceitos avançados, como gráficos e processamento de imagens, usando técnicas como a leitura e identificação de arquivos JPEG. Isso me deu uma visão mais profunda de como os dados são representados em nível binário e como podemos manipulá-los para criar programas mais complexos e sofisticados.

Em resumo, o curso de aritmética de ponteiros me proporcionou um conjunto valioso de habilidades e conhecimentos que tenho aplicado em meus projetos de programação, melhorando minha capacidade de entender e trabalhar com dados em nível de memória e aprimorando minhas práticas de programação em geral.

<details>
  <summary>Mais detalhes exercício Filtro(versão fácil):</summary>
  Ao fazer o curso, aprendi a implementar um programa que aplica filtros a imagens BMP. O curso começou com uma explicação sobre o formato de imagens BMP e como elas são representadas digitalmente. Aprendi que uma imagem é essencialmente uma grade de pixels, onde cada pixel pode ter uma cor diferente. No caso de imagens em preto e branco, cada pixel é representado por um bit, onde 0 pode ser preto e 1 pode ser branco.

  O formato BMP suporta diferentes quantidades de bits por pixel, permitindo representar uma ampla gama de cores. Por exemplo, um BMP de 24 bits usa 8 bits para o vermelho, 8 bits para o verde e 8 bits para o azul em cada pixel. Esses valores de cor podem ser combinados de várias maneiras para criar diferentes cores.

  Além disso, aprendi sobre os cabeçalhos presentes nos arquivos BMP, que armazenam informações como altura, largura e metadados da imagem. Esses cabeçalhos são seguidos pelo bitmap real, que é uma matriz de bytes onde cada triplo de bytes representa a cor de um pixel.

  No curso, também aprendi sobre diferentes filtros que podem ser aplicados a imagens, como escala de cinza, sépia, reflexão, desfoque e detecção de bordas. Cada filtro modifica os pixels da imagem de uma maneira específica para produzir um efeito desejado.

  Para implementar esses filtros, aprendi a trabalhar com a estrutura de dados RGBTRIPLE, que representa um pixel na imagem. As funções que implementam os filtros recebem como entrada uma matriz 2D de pixels, onde cada elemento da matriz é um RGBTRIPLE.

  Ao implementar cada filtro, era necessário percorrer cada pixel da imagem e modificar seus valores de cor de acordo com a lógica do filtro específico. Por exemplo, para o filtro de escala de cinza, era necessário calcular a média dos valores de cor dos pixels para determinar o tom de cinza a ser aplicado.

  Após implementar os filtros, o programa foi capaz de ler uma imagem BMP, aplicar o filtro escolhido pelo usuário e salvar a imagem resultante em um novo arquivo BMP.

  Durante o curso, também aprendi sobre o Makefile, que é um arquivo de configuração utilizado para compilar o programa e facilitar o processo de desenvolvimento.

  No geral, o curso me proporcionou uma compreensão sólida sobre como trabalhar com imagens BMP e aplicar filtros para modificar suas aparências.

  O código foi estruturado no diretório [Modulo-04-Memoria/15_filter](Modulo-04-Memoria/15_filter). Agora sou capaz de escrever código para manipular imagens digitalmente e aplicar uma variedade de efeitos visuais.
  
  Link do teste: [Teste CS50 Filtro(versão fácil)](https://submit.cs50.io/check50/194c06a84725d2dd9576ede375bb7cca9bcf5ed9)
</details>

<details>
  <summary>Mais detalhes exercício Filtro(versão desafiadora):</summary>
  O exercício consiste em implementar um programa que aplique filtros a imagens BMP. As imagens BMP são representadas por uma grade de pixels, onde cada pixel pode ter diferentes valores de cor para vermelho, verde e azul.

  Os filtros a serem implementados são os seguintes:

  Escala de Cinza: Transforma a imagem em uma versão preto e branco, onde a intensidade de cada pixel é determinada pela média dos valores de vermelho, verde e azul desse pixel.

  Sépia: Transforma a imagem em uma versão sépia, dando a ela uma aparência antiga e marrom-avermelhada. Cada pixel é calculado com base nos valores originais de vermelho, verde e azul, conforme uma fórmula específica.

  Refletir: Reflete a imagem horizontalmente, de modo que os pixels do lado esquerdo da imagem terminem no lado direito e vice-versa.

  Desfoque: Aplica um efeito de desfoque à imagem, suavizando os detalhes ao calcular a média dos valores de cor dos pixels vizinhos.

  Para implementar esses filtros, você precisa manipular uma matriz de pixels, onde cada pixel é representado por valores de vermelho, verde e azul. As funções para implementar cada filtro recebem como entrada a altura e largura da imagem, bem como uma matriz 2D de pixels. Essas funções modificam os valores dos pixels para aplicar o efeito desejado.

  É importante lembrar que os valores de cor dos pixels são inteiros, então qualquer cálculo com números de ponto flutuante deve ser arredondado para o inteiro mais próximo.

  O código foi estruturado no diretório [Modulo-04-Memoria/15_filter](Modulo-04-Memoria/15_filter)Além disso, é crucial testar os filtros em arquivos de imagem de amostra fornecidos para garantir que eles estejam funcionando corretamente.
  
  Link do teste: [Teste CS50 Filtro(versão desafiadora)](https://submit.cs50.io/check50/c016442eff5ecaa58edaf627f9dfa6a052087cd9)
</details>

<details>
  <summary>Mais detalhes exercício Recover:</summary>
  Este é um exercício que visa recuperar imagens JPEG de uma imagem forense, que é basicamente um arquivo de dados. Para realizar essa tarefa, primeiro é necessário entender a estrutura dos arquivos JPEG.

  Os arquivos JPEG têm uma assinatura específica nos primeiros bytes, que é 0xff, 0xd8, 0xff e um byte variável começando com 0xe0, 0xe1 ou 0xe2. Portanto, o programa precisa procurar por esses padrões nos dados fornecidos.

  Como as câmeras digitais geralmente armazenam imagens consecutivas em cartões de memória, cada imagem JPEG é seguida imediatamente pela próxima. Além disso, as câmeras geralmente usam um sistema de arquivos FAT com blocos de 512 bytes. Isso significa que é possível buscar as assinaturas JPEG apenas nos primeiros quatro bytes de cada bloco de 512 bytes.

  O programa itera sobre o arquivo de imagem forense, lendo 512 bytes de cada vez em um buffer. Ele verifica se esses 512 bytes contêm a assinatura de um JPEG. Se sim, começa a escrever os bytes em um novo arquivo JPEG. Esse processo continua até que outra assinatura de JPEG seja encontrada, indicando o início de um novo arquivo.

  Para implementar isso, o programa utiliza a função fread para ler os dados do arquivo de imagem, e fwrite para escrever os dados em novos arquivos JPEG. O programa continua a ler e escrever até o final do arquivo de imagem forense ser alcançado.

  No final, o programa gera vários arquivos JPEG numerados sequencialmente, começando com 000.jpg, contendo as imagens recuperadas do arquivo de imagem forense fornecido.

  Para garantir a precisão do programa, é importante testar as imagens recuperadas visualmente e excluir quaisquer arquivos JPEG gerados incorretamente. Isso pode ser feito com o comando rm *.jpg, que exclui todos os arquivos JPEG no diretório de trabalho.

  O código foi estruturado no diretório [Modulo-04-Memoria/16_recover/recover.c](Modulo-04-Memoria/16_recover/recover.c). Para implementar o programa, é necessário utilizar o tipo FILE para manipular os arquivos, além de entender e verificar a estrutura dos arquivos JPEG. O uso de funções como sprintf, fopen, fclose, fread e fwrite é essencial para ler e escrever dados nos arquivos.
  
  Link do teste: [Teste CS50 Recover](https://submit.cs50.io/check50/afe16de1a20b3bafec31764bca5a8a3c419e4214)
</details>

<details>
  <summary>Mais detalhes Laboratório 4 - Volume:</summary>
  No laboratório de Volume, estamos trabalhando em um programa em linguagem C que modifica o volume de um arquivo de áudio no formato WAV. Os arquivos WAV armazenam áudio como uma sequência de amostras, que são números representando o valor do sinal de áudio em um determinado momento. Inicialmente, cada amostra é um inteiro de 2 bytes (16 bits).

  O objetivo é escrever um programa que, dado um arquivo de áudio de entrada, gere um novo arquivo de áudio de saída com o volume modificado. Isso é feito multiplicando cada amostra de áudio por um fator específico.

  No início do programa, é necessário ler o cabeçalho do arquivo de áudio de entrada, que sempre tem 44 bytes, e escrevê-lo no arquivo de saída. Em seguida, percorremos o restante do arquivo, lendo as amostras de áudio, atualizando seus volumes e escrevendo as novas amostras no arquivo de saída.

  Para lidar com isso, usamos diferentes tipos de dados em C, como uint8_t para representar bytes individuais e int16_t para representar amostras de áudio de 16 bits. Além disso, usamos as funções fread() e fwrite() para ler e escrever dados nos arquivos.

  Ao executar o programa, fornecemos três argumentos na linha de comando: o nome do arquivo de entrada, o nome do arquivo de saída e o fator pelo qual o volume será alterado. Por exemplo, se fornecermos um fator de 2.0, o volume será dobrado; se fornecermos 0.5, o volume será cortado pela metade.

  Registrarei minhas conclusões e explicações em [Modulo-04-Memoria/17_volume/volume.c](Modulo-04-Memoria/17_volume/volume.c).No final, nosso programa deve ser capaz de modificar o volume de qualquer arquivo WAV fornecido, mantendo a qualidade do áudio.
  
  Link do teste: [Teste CS50 Volume](https://submit.cs50.io/check50/7516be68d333094de82a7b4d6bcf23bc959a4c65)
</details>

## <a name="modulo05"> Modulo 05 Estruturas de Dados </a>

Aula 5 - Estruturas de Dados

[![Aula 5 - Estruturas de Dados](img/06-Aula05_youtube.png)](https://www.youtube.com/watch?v=TsLGYtezjlA)

Após concluir o Módulo 5 do curso, estou empolgado em compartilhar minha experiência e aprendizado sobre redimensionamento de vetores, estruturas de dados e implementação de arrays e listas encadeadas.

Durante este módulo, mergulhei em conceitos mais avançados de programação. Aprendi sobre a importância do redimensionamento de matrizes e como lidar com a alocação dinâmica de memória utilizando funções como malloc e realloc. Ao trabalhar com matrizes, percebi como é essencial gerenciar eficientemente o espaço de memória, especialmente ao adicionar novos elementos.

Explorar as estruturas de dados foi fascinante. Entendi como as estruturas de dados organizam informações de maneira eficiente na memória, proporcionando flexibilidade no armazenamento e acesso aos dados. Aprendi sobre listas encadeadas e como cada elemento é vinculado por meio de ponteiros, permitindo uma alocação dinâmica de memória e facilitando a inserção e remoção de elementos.

A implementação prática desses conceitos foi desafiadora, mas gratificante. Ao criar minhas próprias estruturas de dados em C, como a lista encadeada, pude entender melhor como os ponteiros funcionam e como manipular efetivamente os elementos.

Explorar árvores como uma estrutura de dados foi um ponto alto deste módulo. Compreendi como os nós são organizados em uma árvore binária e como isso facilita a busca eficiente de elementos. A implementação de funções de pesquisa em árvores binárias me proporcionou uma compreensão mais profunda dos algoritmos de busca.

Além disso, aprendi sobre outras estruturas de dados, como tabelas hash e tries, e como elas podem ser úteis em diferentes contextos de programação. Entendi os trade-offs entre tempo de execução e uso de memória ao escolher a estrutura de dados mais adequada para um determinado problema.

No geral, o Módulo 5 foi uma jornada emocionante e desafiadora. Sinto-me mais confiante em minha capacidade de projetar e implementar algoritmos eficientes, além de escolher as melhores estruturas de dados para resolver problemas complexos de programação. Estou ansioso para aplicar esse conhecimento em projetos futuros e continuar a aprimorar minhas habilidades de programação.

<details>
  <summary>Mais detalhes exercício Speller:</summary>
  Durante o curso, aprendi a desenvolver um programa de verificação ortográfica chamado Speller. O objetivo era criar um programa eficiente que pudesse verificar a ortografia de um arquivo de texto usando uma tabela de hash.

  A primeira etapa foi implementar a função `load`, que carrega um dicionário de palavras de um arquivo para a memória. Isso foi feito manipulando ponteiros e estruturas de dados para armazenar as palavras de forma eficiente.

  Em seguida, implementei a função `hash`, que calcula um valor de hash para cada palavra do dicionário. Isso permitiu uma pesquisa mais rápida e eficiente das palavras durante a verificação de ortografia.

  Após isso, trabalhei na função `size`, que calcula o número de palavras no dicionário carregado na memória. Isso foi útil para otimizar o desempenho do programa e acompanhar o número de palavras verificadas.

  Em seguida, implementei a função `check`, que verifica se uma palavra está no dicionário carregado na memória. Essa função foi projetada para não fazer distinção entre maiúsculas e minúsculas, garantindo que todas as variações de capitalização de uma palavra fossem consideradas corretas.

  Por fim, trabalhei na função `unload`, que libera toda a memória alocada dinamicamente pelo programa, evitando vazamentos de memória.

  Durante o desenvolvimento, foi essencial seguir as especificações fornecidas e garantir que o programa fosse eficiente tanto em termos de tempo quanto de espaço. Fiquei atento aos detalhes, como garantir que o programa tratasse corretamente as palavras possessivas e não vazasse memória.

  Após implementar todas as funções necessárias, pude testar o programa usando diferentes arquivos de texto e o dicionário fornecido. Usei ferramentas como `valgrind` para garantir que não houvesse vazamentos de memória e `diff` para comparar a saída do meu programa com as respostas esperadas.

  Ao longo do curso, adquiri habilidades essenciais em programação em C, manipulação de ponteiros, gerenciamento de memória e otimização de desempenho de programas. Essas habilidades serão valiosas em projetos futuros e no desenvolvimento de software em geral.

  Para sugerir correções, o programa pode usar algoritmos de distância de edição, como o algoritmo de Levenshtein, para encontrar palavras semelhantes no dicionário. Isso permite que o programa sugira correções para palavras mal escritas com base em palavras semelhantes no dicionário.

  O código foi estruturado no diretório [Modulo-05-Estruturas_de_Dados/18_speller/](Modulo-05-Estruturas_de_Dados/18_speller/). Agora sou capaz de escrever programas eficientes de verificação ortográfica e aplicar técnicas avançadas de manipulação de dados em C.
  
</details>

<details>
  <summary>Mais detalhes Laboratório 5 - Herança:</summary>
  Durante o Lab 5, aprendi a simular a herança de tipos sanguíneos em uma família. O objetivo era entender como os alelos A, B e O são transmitidos de geração em geração, determinando o tipo sanguíneo de cada membro da família.

  Comecei criando um diretório chamado lab5 no ambiente de desenvolvimento (IDE) e baixando o código de distribuição para o projeto.
  Ao examinar o código fornecido (inheritance.c), entendi que cada pessoa é representada por uma estrutura chamada person, que contém informações sobre seus pais e alelos sanguíneos.

  Minha tarefa principal era implementar a função create_family, que aloca memória para cada membro da família e define seus alelos e pais com base na geração. Além disso, precisei implementar a função free_family para liberar a memória alocada após o uso.
  Para criar uma família com várias gerações, utilizei recursão na função create_family. Cada pessoa recebe alelos aleatórios de seus pais, seguindo as regras de herança.

  Após implementar as funções, executei o programa inheritance para verificar se a simulação estava correta. O programa imprimiu os tipos sanguíneos de cada membro da família, confirmando que a herança estava sendo simulada corretamente.
  Finalmente, usei o check50 para verificar se meu código atendia aos requisitos especificados pelo laboratório.

  Essa experiência me proporcionou uma compreensão mais profunda dos conceitos de herança genética e alocação dinâmica de memória em C.

  O código foi estruturado no diretório [Modulo-05-Estruturas_de_Dados/19_inheritance/inheritance.c](Modulo-05-Estruturas_de_Dados/19_inheritance/inheritance.c). Agora sou capaz de simular a herança de características genéticas em uma família e entender como os alelos são transmitidos de geração em geração.

  Link do teste: [Teste CS50 Herança](https://submit.cs50.io/check50/ad1985892c1bfd03e297641847a1efad27fff90e)
  
</details>

## <a name="modulo06"> Modulo 06 Python </a>

Aula 6 - Python

[![Aula 6 - Python](img/07-Aula06_youtube.png)](https://www.youtube.com/watch?v=d6ZcOxZYh4Y)

Após concluir o Módulo 6 do curso, estou realmente empolgado com o que aprendi sobre Python! É incrível como esta linguagem está sendo amplamente utilizada atualmente e como é poderosa em termos de simplicidade e recursos adicionais em comparação com outras linguagens.

O professor David de Harvard nos guiou através de conceitos básicos de Python, abordando estruturas como vetores, listas e dicionários, além de algumas funções do CS50. Aprendi como imprimir "hello, world" em Python é tão simples como digitar `print("hello, world")`, sem a necessidade de especificar novas linhas ou terminar com ponto e vírgula.

Exploramos também como ler arquivos em Python e fomos apresentados a algumas bibliotecas interessantes. Fiquei animado para descobrir mais sobre essas bibliotecas conforme avançava nas Anotações da Aula.

Além disso, aprendi sobre as diferenças entre Python e C, como a sintaxe simplificada em Python e a gestão automática de tipos de dados, o que torna a linguagem mais flexível e fácil de usar.

Ao longo do curso, pratiquei a manipulação de strings, listas e dicionários, bem como a implementação de loops e condições em Python. Descobri como as expressões booleanas são tratadas e como as estruturas de controle, como if-elif-else e loops while e for, são utilizadas.

Também experimentei a importação de módulos e bibliotecas em Python, o que me permitiu acessar funcionalidades adicionais e resolver problemas em um nível mais alto de abstração. Por exemplo, aprendi a usar a biblioteca `csv` para trabalhar com arquivos CSV e a biblioteca `pyttsx3` para converter texto em fala.

Ao praticar algoritmos em Python, descobri como implementar pesquisas lineares e como trabalhar com listas, dicionários e conjuntos. Explorei também o conceito de troca de variáveis em Python e a manipulação de arquivos.

Por fim, fiquei impressionado com a variedade de bibliotecas disponíveis em Python, desde aquelas para processamento de imagens e reconhecimento facial até reconhecimento de fala e criação de códigos QR.

Em resumo, minha experiência com o Módulo 6 do curso foi extremamente enriquecedora. Aprendi muito sobre Python e suas aplicações práticas, e estou animado para continuar explorando e aprimorando minhas habilidades nessa linguagem tão versátil e poderosa.

<details>
  <summary>Mais detalhes exercício Hello:</summary>
  Após concluir o curso sobre programação em Python, uma das práticas fundamentais que aprendi foi como criar um simples programa de "Hello World" que captura o nome do usuário e o saúda. Isso me lembrou do primeiro exercício de introdução que fiz na IDE, mas agora aplicado em Python.

  Durante o curso, implementei o código seguindo a especificação fornecida. Basicamente, criei um arquivo chamado hello.py dentro do diretório ~/pset6/hello e escrevi um programa que solicita ao usuário que insira seu nome. Em seguida, o programa imprime uma mensagem de saudação, incluindo o nome fornecido pelo usuário.

  O código foi estruturado no diretório [Modulo-06-Python/20_hello/hello.py](Modulo-06-Python/20_hello/hello.py). Essa experiência me ajudou a reforçar conceitos básicos de entrada e saída em Python, além de me familiarizar ainda mais com a linguagem.

  Link do teste: [Teste CS50 Hello](https://submit.cs50.io/check50/bb9fa10a07d9fa65723d74170fac2939edf18c93)
</details>

<details>
  <summary>Mais detalhes exercício Mario Less:</summary>
  Durante o curso, aprendi a implementar um programa em Python que imprime uma pirâmide de Mario, semelhante àquela que fiz em C. A pirâmide é formada por blocos de tijolos, onde cada linha tem um número diferente de tijolos.
  
  A importância de solicitar e validar entradas do usuário para garantir que o programa funcione corretamente. Por isso, ao desenvolver o programa, implementei um mecanismo para solicitar a altura da meia-pirâmide, assegurando que fosse um número inteiro positivo entre 1 e 8.

  Além disso, aprendi a utilizar loops e comandos de impressão para gerar a meia-pirâmide desejada. Garanti que a pirâmide estivesse alinhada com o canto inferior esquerdo do terminal e que não houvesse espaços extras no final de cada linha.

  Ao testar o programa, verifiquei sua robustez ao digitar diferentes tipos de entrada. Por exemplo, ao digitar valores inválidos, como -1, 0, 9, ou até mesmo palavras, o programa rejeitou essas entradas e solicitou ao usuário que fornecesse um número válido.

  Por fim, executei várias instâncias do programa, inserindo diferentes alturas para a meia-pirâmide e confirmando se a saída estava de acordo com o esperado, garantindo assim a correta execução do código em diferentes cenários.

  O código foi estruturado no diretório [Modulo-06-Python/21_mario_less/mario.py](Modulo-06-Python/21_mario_less/mario.py).Este exercício foi uma excelente oportunidade para aplicar os conhecimentos adquiridos durante o curso e consolidar minhas habilidades em Python.

  Link do teste: [Teste CS50 Mario Less](https://submit.cs50.io/check50/427632d2eaa68683eff66f1032829600589dc024)
</details>

<details>
  <summary>Mais detalhes exercício Mario More:</summary>
  Uma das tarefas desafiadoras que enfrentei foi a implementação de um programa que cria uma meia-pirâmide dupla. Esta tarefa exigiu não apenas entender os conceitos básicos de loops e estruturas de controle, mas também a capacidade de solicitar entrada do usuário e validar essa entrada.

  No meu programa Python chamado "mario.py", eu criei uma lógica que solicita ao usuário a altura desejada da meia-pirâmide. Garanti que o programa aceitasse apenas valores inteiros positivos entre 1 e 8, como requisitado. Se o usuário inserisse um valor fora desse intervalo ou algo que não fosse um número, meu programa rejeitaria a entrada e pediria uma nova entrada válida.

  Após obter a altura desejada da meia-pirâmide, utilizei loops e instruções de impressão para criar a meia-pirâmide dupla usando "#" como blocos. Garanti que as pirâmides estivessem alinhadas com o canto inferior esquerdo do terminal, com dois espaços entre elas e sem espaços extras após o último conjunto de "#" em cada linha.

  Testei minuciosamente meu programa para garantir que ele se comportasse conforme o esperado em diferentes cenários. Por exemplo, verifiquei se ele rejeitava entradas inválidas, como números fora do intervalo permitido e entradas que não eram números. Além disso, verifiquei se as meia-pirâmides eram geradas corretamente para diferentes alturas especificadas pelo usuário.

  Concluir esse exercício não apenas me ajudou a praticar os conceitos fundamentais de Python, mas também me permitiu desenvolver minhas habilidades de resolução de problemas e validação de entrada do usuário. 

  O código foi estruturado no diretório [Modulo-06-Python/22_mario_more/mario.py](Modulo-06-Python/22_mario_more/mario.py). Estou confiante de que posso aplicar essas habilidades em projetos futuros e continuar a aprimorar meu conhecimento em programação.

  Link do teste: [Teste CS50 Mario More](https://submit.cs50.io/check50/fcf771099be3957b3c02847cbb1dd7c8a62dea87)
</details>

<details>
  <summary>Mais detalhes exercício Dinheiro:</summary>
  Uma das práticas que aprendi foi a implementação de um programa para calcular o número mínimo de moedas necessárias para dar troco a um usuário.

  Em primeiro lugar, criei um arquivo chamado cash.py em ~/pset6/cash/, onde desenvolvi o programa. Utilizei a função get_float da biblioteca CS50 para receber a entrada do usuário e a função print para produzir a resposta.

  O programa solicita ao usuário que insira o valor do troco devido. Em seguida, ele calcula o número mínimo de moedas necessário para esse troco, considerando apenas moedas de 25¢, 10¢, 5¢ e 1¢.

  Uma parte importante foi garantir que o programa tratasse corretamente diferentes formatos de entrada, como dólares e centavos. Por exemplo, se o troco devido fosse $9.75, o programa esperaria a entrada do usuário como 9.75, não como $9.75 ou 975. No entanto, se o troco fosse exatamente $9, o programa aceitaria a entrada como 9.00 ou apenas 9.

  Além disso, o programa foi projetado para lidar com casos em que o usuário fornece um valor não negativo. Se o usuário inserir um valor negativo, o programa solicitará novamente uma entrada válida até que o usuário concorde.

  Finalmente, para automatizar os testes do código, a última linha de saída do programa foi configurada para exibir apenas o número mínimo de moedas possível, seguido por uma nova linha.

  Após escrever o programa, realizei testes para garantir seu funcionamento adequado. Executei o programa com diferentes valores de troco e verifiquei se o número mínimo de moedas gerado estava correto. Também testei o comportamento do programa em situações de entrada inválida, como valores negativos, letras ou entrada vazia, garantindo que o programa rejeitasse essas entradas e solicitasse uma nova entrada ao usuário.

  Essa prática foi muito útil para aprimorar minhas habilidades em Python e desenvolver a capacidade de resolver problemas de forma eficiente e precisa. 

  O código foi estruturado no diretório [Modulo-06-Python/23_dinheiro/cash.py](Modulo-06-Python/23_dinheiro/cash.py). Agora me sinto mais confiante em lidar com tarefas que envolvem cálculos financeiros e manipulação de dados em Python.

  Link do teste: [Teste CS50 Dinheiro](https://submit.cs50.io/check50/c643afe8d6b0d79f24cbc38e3c982b1dbb298ea8)
</details>

<details>
  <summary>Mais detalhes exercício Crédito (versão desafiadora):</summary>
  Durante o curso, aprendi a implementar um programa em Python que verifica se um número de cartão de crédito é válido de acordo com o algoritmo de Luhn. Este algoritmo é utilizado para validar a autenticidade de números de cartão de crédito. 

  Ao escrever o programa, aprendi a solicitar ao usuário um número de cartão de crédito e a verificar se é um número válido da American Express, MasterCard ou Visa, como exigido pelo exercício. Utilizei as funções `get_int` ou `get_string` da biblioteca CS50 para obter a entrada do usuário, dependendo da implementação escolhida.

  Para automatizar a validação do número de cartão de crédito, aprendi a utilizar expressões regulares com o módulo `re` do Python para garantir que a entrada do usuário consista apenas em dígitos e tenha o comprimento correto.

  Após implementar o programa, realizei testes para verificar se estava funcionando corretamente. Digitei diferentes números de cartão de crédito, como os exemplos fornecidos no exercício, e meu programa identificou corretamente se eram AMEX, MASTERCARD, VISA ou inválidos, conforme esperado.

  O código foi estruturado no diretório [Modulo-06-Python/24_credito/credit.py](Modulo-06-Python/24_credito/credit.py). Essa prática me proporcionou uma compreensão mais profunda sobre algoritmos de validação e me permitiu aplicar meus conhecimentos em Python para resolver problemas do mundo real, como a verificação da autenticidade de números de cartão de crédito.

  Link do teste: [Teste CS50 Legibilidade](https://submit.cs50.io/check50/c7f8718cd93b71286d131b97b7e86f05554da1de)
</details>

<details>
  <summary>Mais detalhes exercício Crédito (versão desafiadora):</summary>
  Durante o curso, aprendi a desenvolver um programa em Python chamado "readability.py" que calcula o nível escolar aproximado necessário para compreender um texto. A especificação era clara: primeiro, o programa solicita ao usuário que insira um texto. Em seguida, ele determina o nível escolar necessário para compreender esse texto com base na fórmula Coleman-Liau. Essa fórmula considera o número médio de letras por 100 palavras e o número médio de sentenças por 100 palavras.

  Ao escrever o programa, precisei contar o número de letras, palavras e frases no texto fornecido pelo usuário. Uma letra foi definida como qualquer caractere alfabético, e uma palavra foi considerada como qualquer sequência de caracteres separados por espaços. Além disso, qualquer ocorrência de ponto final, ponto de exclamação ou ponto de interrogação indicou o final de uma frase.

  A saída do programa foi formatada para mostrar o resultado como "Grade X", onde X é o nível escolar calculado pela fórmula Coleman-Liau, arredondado para o número inteiro mais próximo. Se o resultado foi 16 ou superior, o programa exibiu "Grade 16+" em vez de fornecer o número exato. Se o resultado foi menor que 1, o programa imprimiu "Before Grade 1".

  Testei o programa com diferentes textos para garantir seu correto funcionamento. Após esses testes, confirmei que o programa conseguia determinar com precisão o nível escolar aproximado necessário para compreender um texto, de acordo com a fórmula Coleman-Liau. 

  O código foi estruturado no diretório [Modulo-06-Python/25_legibilidade/readability.py](Modulo-06-Python/25_legibilidade/readability.py). A prática com este exercício me proporcionou uma melhor compreensão sobre processamento de texto em Python e como aplicar fórmulas matemáticas para resolver problemas específicos.

  Link do teste: [Teste CS50 Legibilidade](https://submit.cs50.io/check50/a37730385e4d7da4e432311dd310eaee6e811df7)
</details>

<details>
  <summary>Mais detalhes exercício DNA:</summary>
  Desde que concluí o curso sobre DNA, minha compreensão sobre como identificar indivíduos com base em sua sequência genética se aprofundou significativamente. Uma das principais lições que aprendi foi sobre os Short Tandem Repeats (STRs), que são sequências curtas de bases de DNA repetidas consecutivamente em locais específicos. Aprendi que a variação no número de repetições desses STRs entre os indivíduos pode ser utilizada para identificar pessoas de forma única.

  Durante o curso, implementei um programa em Python chamado `dna.py` que realiza essa identificação. O programa recebe como entrada um arquivo CSV contendo contagens de STRs para uma lista de indivíduos e um arquivo de texto contendo a sequência de DNA a ser identificada. Ao executar o programa, ele analisa a sequência de DNA e compara suas contagens de STRs com as do banco de dados fornecido. Se encontrar uma correspondência exata, o programa imprime o nome do indivíduo correspondente; caso contrário, imprime "No match".

  Uma parte importante do processo foi entender como calcular a execução mais longa de repetições consecutivas de cada STR na sequência de DNA. Para isso, utilizei técnicas de manipulação de strings em Python e estruturas de dados como listas e dicionários para rastrear as informações necessárias.

  Ao final do curso, realizei uma série de testes para garantir que o programa funcionasse corretamente. Testei com diferentes sequências de DNA e bancos de dados de STRs, verificando se o programa produzia os resultados esperados em cada caso. 

  O código foi estruturado no diretório [Modulo-06-Python/26_dna/dna/dna.py](Modulo-06-Python/26_dna/dna/dna.py). Em resumo, a experiência adquirida durante o curso me proporcionou um entendimento mais profundo sobre a análise de DNA e a identificação de pessoas com base em suas sequências genéticas, além de fortalecer minhas habilidades de programação em Python.

  Link do teste: [Teste CS50 DNA](https://submit.cs50.io/check50/5f44274742140ebdcc3d639f8f23edd21f108635)
</details>

<details>
  <summary>Mais detalhes Laboratório 6 - Copa do Mundo:</summary>
  Minha experiência com o curso sobre simulação da Copa do Mundo FIFA foi realmente fascinante. Durante o curso, aprendi a utilizar o Python para criar um programa que simula o desenrolar do torneio, estimando as chances de vitória de cada equipe participante.

  Primeiramente, ao analisar os dados fornecidos nos arquivos CSV, percebi que as informações continham os nomes das equipes participantes e suas respectivas classificações. Essas classificações, baseadas nas avaliações da FIFA, foram cruciais para estimar as probabilidades de vitória de cada equipe em um jogo.

  Com o auxílio do Python, desenvolvi um programa capaz de simular o torneio repetidamente, rodada após rodada, até restar apenas uma equipe como vencedora. Para isso, implementei funções que simulavam os jogos entre as equipes e atualizavam o progresso do torneio de acordo com os resultados.

  Ao executar o programa, pude observar as probabilidades estimadas de vitória para cada equipe. A cada execução, as probabilidades variavam um pouco devido à aleatoriedade inserida nas simulações, o que tornava o processo ainda mais interessante.

  Ao finalizar o curso e aplicar o que aprendi, fiquei surpreso com o quão precisas as estimativas se mostraram em relação aos resultados reais das Copas do Mundo de 2018 e 2019. Por exemplo, o programa previu com precisão que a França venceria a Copa do Mundo masculina de 2018, enquanto os Estados Unidos sairiam vitoriosos na competição feminina de 2019.

  Através desse curso, não apenas adquiri habilidades em programação Python, mas também ganhei uma compreensão mais profunda sobre a importância das simulações e das análises de dados em eventos esportivos de grande escala como a Copa do Mundo FIFA. 

  O código foi estruturado no diretório [Modulo-06-Python/27_lab_copa/lab6/tournament.py](Modulo-06-Python/27_lab_copa/lab6/tournament.py). Foi uma experiência enriquecedora que certamente aplicarei em outros projetos futuros.

  Link do teste: [Teste CS50 Copa do Mundo](https://submit.cs50.io/check50/92fff4b01de4dcde94cdbcf1c554ed8cb104411c)
</details>

## <a name="modulo07"> Modulo 07 SQL </a>

Aula 7 - SQL

[![Aula 7 - SQL](img/08-Aula07_youtube.png)](https://www.youtube.com/watch?v=8mAL2E-0-lw)

Depois de concluir o Módulo 7 sobre SQL, aprendi uma variedade de conceitos e práticas importantes relacionados a bancos de dados e linguagem SQL. Uma das principais áreas de aprendizado foi o processamento de dados, onde aprendi a coletar dados de fontes diferentes e a manipulá-los de forma eficiente.

Por exemplo, aprendi a limpar dados, o que envolveu a remoção de espaços em branco extras e a padronização de dados para facilitar a análise. Também explorei métodos para contar e buscar dados, o que me permitiu extrair insights úteis de conjuntos de dados grandes.

Além disso, aprendi sobre bancos de dados relacionais e como usar SQL para interagir com eles. Aprendi a criar e manipular tabelas, executar consultas para recuperar dados específicos e usar diferentes cláusulas e funções para filtrar e ordenar resultados.

Um aspecto particularmente interessante foi aprender sobre a normalização de dados e a importância de projetar esquemas de banco de dados eficientes. Isso incluiu entender como dividir dados em tabelas separadas e usar chaves estrangeiras para estabelecer relacionamentos entre elas.

Durante o curso, também explorei problemas comuns em bancos de dados, como ataques de injeção de SQL e condições de corrida. Aprendi a aplicar técnicas de prevenção, como o uso de parâmetros de consulta para evitar injeções de SQL e o uso de transações para garantir a integridade dos dados em ambientes multiusuários.

No geral, o curso me proporcionou uma compreensão sólida dos fundamentos de bancos de dados e SQL, e estou ansioso para aplicar esses conhecimentos em projetos futuros.

<details>
  <summary>Mais detalhes exercício Filmes:</summary>
  Durante o curso, aprendi a usar consultas SQL para explorar e analisar um banco de dados de filmes. Comecei baixando o problema no meu próprio ambiente de desenvolvimento. Depois de entender a estrutura do banco de dados, comecei a escrever consultas para responder a várias perguntas sobre os filmes.

  Por exemplo, uma das consultas que aprendi a fazer foi listar os títulos de todos os filmes lançados em 2008. Isso envolveu escrever uma consulta SQL que seleciona os títulos dos filmes da tabela de filmes onde o ano de lançamento é 2008.

  Outra consulta interessante foi determinar o ano de nascimento da atriz Emma Stone. Aqui, escrevi uma consulta para encontrar o ano de nascimento dela na tabela de pessoas, usando seu nome como referência.

  Também pratiquei consultas mais complexas, como listar os nomes de todas as pessoas que estrelaram um filme no qual Kevin Bacon também estrelou. Isso exigiu a identificação de todos os filmes em que Kevin Bacon participou e, em seguida, encontrar todas as pessoas que estrelaram esses filmes, excluindo o próprio Kevin Bacon.

  Ao longo do curso, pude aprimorar minhas habilidades em escrever consultas SQL eficazes e precisas para extrair informações específicas do banco de dados de filmes.

  O código foi estruturado no diretório [Modulo-07-SQL/28_movies/movies/](Modulo-07-SQL/28_movies/movies/). Essa prática me proporcionou uma compreensão mais profunda sobre consultas SQL e como interagir com bancos de Essas habilidades são úteis não apenas para análise de dados de filmes, mas também podem ser aplicadas a uma variedade de outras áreas que utilizam bancos de dados relacionais.

  Link do teste: [Teste CS50 Filmes](https://submit.cs50.io/check50/aa38e437597fa55fe2cdd38d2392a1c6ba52ca9c)
</details>

<details>
  <summary>Mais detalhes exercício Fiftyville:</summary>
  Ao longo do curso, tive a oportunidade de me envolver em um emocionante exercício de resolução de mistério chamado Fiftyville. O desafio era investigar o roubo do pato de estimação do CC50 em Fiftyville, uma cidade fictícia. Com base nos registros da cidade disponíveis em um banco de dados SQLite chamado fiftyville.db, minha tarefa era identificar o ladrão, para onde ele fugiu e quem foi seu cúmplice.

  Para começar, acessei o banco de dados e comecei a realizar consultas SQL para acessar informações relevantes. Mantive um registro de todas as consultas executadas no arquivo log.sql, onde também incluí comentários explicando meu raciocínio e o que esperava obter de cada consulta. Esse registro serviu como evidência do processo que utilizei para resolver o mistério.

  Iniciei minha investigação examinando a tabela crime_scene_reports, buscando relatórios que correspondessem à data e ao local do crime, que ocorreu em 28 de julho de 2020 na Chamberlin Street. A partir daí, expandi minha busca para outras tabelas relevantes, como suspects e getaway_cars, procurando por pistas que pudessem me levar ao ladrão, à cidade para onde ele fugiu e ao seu cúmplice.

  Depois de analisar cuidadosamente os dados e seguir várias pistas, finalmente consegui identificar o ladrão, a cidade para onde ele fugiu e seu cúmplice. Registrei minhas conclusões no arquivo answers.txt, preenchendo as informações solicitadas.

  Essa experiência me proporcionou uma prática valiosa na aplicação de consultas SQL para resolver problemas do mundo real, além de desenvolver minhas habilidades de raciocínio analítico e resolução de problemas. 

  O código foi estruturado no diretório [Modulo-07-SQL/29_fiftyville/answers.txt](Modulo-07-SQL/29_fiftyville/answers.txt). Foi um desafio empolgante e gratificante que me ajudou a consolidar meu entendimento de bancos de dados relacionais e consultas SQL. 

  Link do teste: [Teste CS50 Fiftyville](https://submit.cs50.io/check50/91ad722271cb140e9778715008f05cceb0ae149c)
  </details>

<details>
  <summary>Mais detalhes Laboratório 5 - Songs:</summary>
  Após concluir o curso sobre consultas SQL para bancos de dados de músicas, pude aprimorar minhas habilidades na manipulação de dados usando o SQLite. O laboratório 7, intitulado "Songs", foi especialmente útil para aplicar esses conhecimentos na prática.

  Ao acessar o banco de dados fornecido, chamado songs.db, contendo informações do Spotify sobre as 100 principais músicas transmitidas em 2018, comecei a explorar e a responder várias perguntas utilizando consultas SQL.

  Primeiramente, escrevi uma consulta para listar os nomes de todas as músicas presentes no banco de dados. Isso me permitiu visualizar todas as músicas disponíveis em uma tabela simples.

  Em seguida, ordenei os nomes das músicas em ordem crescente de ritmo, utilizando outra consulta SQL. Essa tarefa me ajudou a compreender como classificar os dados de acordo com critérios específicos.

  Outro desafio foi listar as cinco músicas mais longas, em ordem decrescente de duração. Isso exigiu o uso de funções de agregação e ordenação para obter os resultados desejados.

  Além disso, explorei consultas mais complexas, como encontrar músicas com dançabilidade, energia e valência acima de 0,75, e calcular a energia média de todas as músicas. Essas consultas me permitiram entender como filtrar dados com base em condições específicas e calcular estatísticas sobre o conjunto de dados.

  Também pratiquei a busca por músicas de artistas específicos, como Post Malone e Drake, sem fazer suposições sobre os identificadores dos artistas.

  Por fim, escrevi uma consulta para identificar músicas que apresentam participações de outros artistas, observando se o nome da música continha a marcação "feat.".

  O código foi estruturado no diretório [Modulo-07-SQL/29_fiftyville/answers.txt](Modulo-07-SQL/30_songs/). No geral, o laboratório 7 proporcionou uma experiência prática valiosa para aprimorar minhas habilidades em consultas SQL e aplicá-las a um contexto real de análise de dados musicais.

  Link do teste: [Teste CS50 Songs](https://submit.cs50.io/check50/e4105d3153b895c65fe60bad65746e1e7f2fc2c8)
  </details>

## <a name="modulo08








## <a name="licença"> Licença </a>

<a href="https://www.buymeacoffee.com/claudiomendonca" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 60px !important;width: 217px !important;" ></a>

Copyright © 2024 <a href="https://www.claudiomendonca.eng.br" target="_blank">ClaudioMendonca.eng.br</a> . The [MIT License](https://github.com/ClaudioMendonca-Eng/CS50_Harvard-CC50_Ifood?tab=MIT-1-ov-file) (MIT)
