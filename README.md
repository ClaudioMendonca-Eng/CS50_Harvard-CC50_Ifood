# CS50_Harvard-CC50_Ifood

Estou empolgado para compartilhar sobre a nova versão do CC50, o curso introdutório de Ciência da Computação de Harvard, que está repleto de conteúdo e novidades incríveis! Esse curso renomado mundialmente oferece uma sólida base em computação, Internet, programação e muito mais, tudo de forma gratuita.

Durante o curso, exploramos o funcionamento de computadores, a Internet e desenvolvemos habilidades em programação. Ao término, estaremos prontos para iniciar projetos em áreas como Web Design, Bancos de Dados, Sistemas Eletrônicos e Programação de Software. Apesar de desafiador, o curso é acessível a todos, independentemente da experiência em programação.

O professor David J. Malan utiliza uma didática incrível, tornando o aprendizado ainda mais enriquecedor. Todos os materiais, incluindo a tradução das aulas e dos Sets de Problemas, são diretamente do material original da Harvard (CS50 2021 - licença do CS50), garantindo que tenhamos acesso ao mesmo conhecimento dos alunos da universidade.

A experiência é aprimorada com o ambiente de desenvolvimento, conhecido como IDE, que agora conta com Inteligência Artificial. Isso significa que podemos programar sem a necessidade de instalar qualquer software. O curso também oferece um servidor no Discord e um fórum no Discourse para facilitar a interação e discussão entre os participantes.

Ao finalizar o curso, podemos obter um certificado pela Fundação Estudar. Uma novidade emocionante é a disponibilidade de legendas em português, proporcionando uma ótima oportunidade para aprender e praticar inglês.

O CC50 é mais do que um curso, é uma experiência que nos desafia, expande nossa visão sobre problemas do mundo real e nos prepara para diversos caminhos profissionais. É como ter Harvard no Brasil, e estou ansioso para explorar todas as oportunidades que esse curso incrível oferece!

## Tecnologias
<div>
  <img src="https://img.shields.io/badge/Developer-239120?style=for-the-badge&logo=c&logoColor=white">
</div>

- [Instrutores](#instrutor)
- [Apresentação](#apresentacao)
- [Modulo 00 Scratch](#modulo00)
- [Modulo 01 C](#modulo01)
- [Modulo 02 Arrays](#modulo02)
- [Modulo 03 Algoritmos](#modulo03)
- [Modulo 04 Memória](#modulo04)
- [Modulo 05 Estruturas de Dados](#modulo05)
- [Modulo 06 Python](#modulo06)
- [Modulo 07 SQL](#modulo07)
- [Modulo 08 HTML CSS JavaScript](#modulo08)
- [Modulo 09 Flask](#modulo09)
- [Modulo 10 Etica](#modulo10)
- [Encerramento do Curso](#encerramento)
- [Licença](#licença)

## <a name="instrutor"> Instrutores </a>

- [David J. Malan](https://cs.harvard.edu/malan/) - Professor de Ciência da Computação em Harvard
- [Brian Yu](https://cs.harvard.edu/malan/) - Instrutor de Ciência da Computação em Harvard
- [Doug Lloyd](https://cs.harvard.edu/malan/) - Instrutor de Ciência da Computação em Harvard

## <a name="apresentacao"> Apresentação </a>

O curso CC50 é uma versão do curso CS50, que é o curso introdutório de Ciência da Computação de Harvard, que está repleto de conteúdo e novidades incríveis! Esse curso renomado mundialmente oferece uma sólida base em computação, Internet, programação e muito mais, tudo de forma gratuita.
Durante o curso, exploramos o funcionamento de computadores, a Internet e desenvolvemos habilidades em programação. Ao término, estaremos prontos para iniciar projetos em áreas como Web Design, Bancos de Dados, Sistemas Eletrônicos e Programação de Software. Apesar de desafiador, o curso é acessível a todos, independentemente da experiência em programação.
O professor David J. Malan utiliza uma didática incrível, tornando o aprendizado ainda mais enriquecedor. Todos os materiais, incluindo a tradução das aulas e dos Sets de Problemas, são diretamente do material original da Harvard (CS50 2021 - licença do CS50), garantindo que tenhamos acesso ao mesmo conhecimento dos alunos da universidade.
A experiência é aprimorada com o ambiente de desenvolvimento, conhecido como IDE, que agora conta com Inteligência Artificial. Isso significa que podemos programar sem a necessidade de instalar qualquer software. O curso também oferece um servidor no Discord e um fórum no Discourse para facilitar a interação e discussão entre os participantes.
Ao finalizar o curso, podemos obter um certificado pela Fundação Estudar. Uma novidade emocionante é a disponibilidade de legendas em português, proporcionando uma ótima oportunidade para aprender e praticar inglês.
O CC50 é mais do que um curso, é uma experiência que nos desafia, expande nossa visão sobre problemas do mundo real e nos prepara para diversos caminhos profissionais. É como ter Harvard no Brasil, e estou ansioso para explorar todas as oportunidades que esse curso incrível oferece!

## <a name="modulo00"> Modulo 00 Scratch </a>

Na aula 0, exploramos diversos tópicos essenciais da Ciência da Computação. Começamos com uma calorosa recepção e uma introdução ao curso, abordando conceitos como representação numérica, algoritmos, pseudocódigo e outras fundamentais da disciplina.
  
A discussão sobre representação numérica incluiu sistemas como unário, decimal e binário, este último sendo o utilizado pelos computadores. A compreensão de como números são representados é crucial para entender o funcionamento interno dos dispositivos eletrônicos.
  
Exploramos também a representação de texto através de códigos como ASCII e Unicode, que mapeiam números para caracteres, possibilitando a exibição de letras, números e símbolos em computadores. Além disso, discutimos como imagens, vídeos e sons são representados por bits, permitindo a criação e reprodução de conteúdo visual e auditivo.
  
O conceito de algoritmos foi introduzido como uma abordagem sistemática para resolver problemas. Analisamos a eficiência de diferentes algoritmos, destacando a importância de projetar soluções que sejam não apenas corretas, mas também eficientes em termos de tempo de execução.
  
O pseudocódigo foi apresentado como uma ferramenta para descrever algoritmos em uma linguagem próxima do inglês, facilitando a compreensão e o planejamento de soluções. Observamos como as funções, condições, expressões booleanas e loops são elementos essenciais na criação de algoritmos estruturados.
  
Em resumo, esta aula inaugural proporcionou uma visão abrangente dos conceitos fundamentais da Ciência da Computação, estabelecendo as bases para explorarmos temas mais avançados ao longo do curso. Estou empolgado para continuar aprendendo e aplicando esses conhecimentos na prática!

<details>
  <summary>Mais detalhes Scratch</summary>
  Agora, ao explorar o Scratch, começamos a criar programas utilizando blocos de construção como funções, condições, expressões booleanas e rotações. Ao contrário da linguagem de programação baseada em texto C, o Scratch utiliza uma abordagem gráfica, permitindo-nos arrastar e soltar blocos que contêm instruções.
  
  No ambiente do Scratch, compreendemos a estrutura, onde temos um palco para exibir o programa, peças de quebra-cabeça representando funções ou variáveis, e a possibilidade de adicionar personagens. Experimentamos a criação de programas simples, como fazer o gato dizer "olá, mundo", utilizando blocos como "say" e "green flag clicked".
  
  Exploramos a extensão "text-to-speech", que converte texto em áudio, e experimentamos com a criação de programas mais complexos, como fazer o gato miar ou desenhar quando o mouse é clicado. Introduzimos conceitos como variáveis, loops, e extensões como "Translate" para tradução de idiomas.
  
  Ao observar demos como Gingerbread tales remix e Oscartime, percebemos a importância do design e da abstração para criar programas mais legíveis e eficientes. Concluímos com a compreensão de que as habilidades adquiridas no curso, como resolução de problemas e algoritmos, têm aplicações além da ciência da computação.
</details>

<details>
  <summary>Mais detalhes exercício:</summary>
  Agora é a minha vez de escolher uma aventura no Scratch! A tarefa é criar um projeto à minha escolha, seja uma história interativa, jogo, animação, ou qualquer outra coisa. Existem alguns requisitos a seguir:
  
  O projeto deve ter pelo menos dois sprites, sendo que um deles não deve ser um gato.
  Preciso criar pelo menos três scripts no total, distribuídos entre os sprites.
  Uso de pelo menos uma condição no projeto.
  Implementação de pelo menos um loop.
  Utilização de pelo menos uma variável.
  Inclusão de pelo menos um som no projeto.
  O projeto deve ser mais complexo do que a maioria apresentada nas aulas, mas não necessariamente tão complexo quanto o Ivy’s Hardest Game.
  Para me inspirar, posso explorar projetos de alunos anteriores ou tutoriais no Scratch. No entanto, é encorajado que eu pense em uma ideia própria antes de começar a implementá-la. A estratégia é avançar passo a passo, escrevendo pequenos trechos de código, testando, e repetindo o processo. A cada poucos minutos, devo salvar meu trabalho para não perder nada.
  
  Se encontrar dificuldades, posso ajustar o design ou contornar o problema. O importante é me divertir ao implementar uma ideia que eu ache interessante. Ao concluir o projeto, devo salvar e compartilhar o arquivo para mostrar aos colegas e familiares. Estou pronto para a aventura no Scratch!

</details>

Explorando a Selva Criativa do Scratch: O Desafio do Dinossauro Google!

Recentemente, aventurei-me na selva criativa do Scratch, enfrentando o desafio de criar um projeto envolvente e único. Escolhi como meu campo de experimentação a recriação do lendário Dinossauro do Google, aquela simpática criatura pré-histórica que pula sobre obstáculos quando a conexão de internet se perde.

O coração do meu projeto pulsou seguindo as diretrizes propostas, adicionando camadas de complexidade e diversão. Com pelo menos dois sprites em cena, meu mundo ganhou vida com um dinossauro como protagonista e um cenário repleto de desafios. Criar três scripts, cada um uma sinfonia de comandos e ações, proporcionou um toque especial à experiência do jogador.

Ao adentrar na selva do Scratch, as condições se tornaram o terreno onde a diversão se desenrolava. Estabelecer regras de jogo, determinando quando o dinossauro deveria saltar ou abaixar, deu um toque estratégico ao meu projeto. A introdução de loops permitiu que o dinossauro enfrentasse uma série de desafios em movimento contínuo, mantendo os jogadores em suspense.

A criatividade floresceu com a introdução de variáveis, elementos dinâmicos que deram vida ao jogo. A cada salto e esquiva, as variáveis registravam pontos e desencadeavam eventos especiais, tornando a experiência interativa e envolvente.

Apesar de não incorporar sons no projeto, a atmosfera do jogo permanece intensa. Cada pulo do dinossauro, cada vitória e derrota são marcados por uma trilha sonora imaginativa, criada mentalmente durante a exploração da selva virtual.

A combinação desse esforço criativo encontra-se no meu projeto do Dinossauro Google, agora disponível para explorar e desfrutar [aqui](https://scratch.mit.edu/projects/971443808). Cada linha de código é um fragmento do meu entusiasmo, cada comando uma escolha deliberada para criar uma experiência única. Sinta-se convidado a aventurar-se na terra dos dinossauros, onde a diversão é infinita, e a criatividade não conhece limites!

![](img/01-scratch-dinossauro.png)

Link para o projeto: [Dinossauro Google](https://scratch.mit.edu/projects/971443808)


<details>
  <summary>Clique para ver o spoiler</summary>
  teste Este é o texto que será ocultado.
</details>


## <a name="modulo01"> Modulo 01 C </a>

Hoje dei início ao Módulo 1 do curso CC50. Na segunda aula, fui introduzido à linguagem de programação C e aprendi sobre conceitos como compilação, funções, argumentos, ferramentas e comandos, tipos e formatos de código. Conheci a IDE do curso e explorei os conceitos de operadores, limitações, truncamentos, estruturas condicionais, repetição, expressões booleanas, abstração, header de arquivos, função main, memória e overflow.

Durante a aula, discutimos tópicos como a linguagem C, CS50 IDE, compilação, funções e argumentos, ferramentas, comandos, tipos e códigos de formato, operadores, limitações, truncamento, variáveis, açúcar sintático, condicionais, expressões booleanas, loops, abstração, memória, imprecisão e overflow.

Em seguida, exploramos um exemplo de código em C, onde aprendi a estrutura básica de um programa nessa linguagem:
  
  ```c
  #include <stdio.h>
  int main(void) 
    {
        printf("olá, mundo"); 
    }
  ```
Mesmo que inicialmente absorver esses novos conceitos pareça desafiador, acredito que ao longo do semestre me tornarei mais capacitado e experiente na aplicação desses conhecimentos. Fiz algumas anotações sobre as principais ideias, como correção, design e estilo na programação.

Utilizando a CS50 IDE, uma plataforma baseada em nuvem, pude escrever e compilar meu código em C. A compilação foi necessária porque os computadores entendem apenas linguagem binária, e o código fonte em C precisa ser convertido para essa forma. Utilizei comandos como make hello para compilar e ./hello para executar meu programa.

Exploramos também o conceito de funções e argumentos em C, comparando-os aos blocos do Scratch. Aprendi sobre a função printf e a importância de bibliotecas, como a Biblioteca CS50, que fornece funções prontas para uso, como get_string. Adaptei o código para solicitar o nome do usuário e imprimir uma saudação personalizada.

Além disso, compreendi a importância da função main e dos arquivos de cabeçalho (.h) em C, assim como a necessidade de ferramentas como help50, style50 e check50 para auxiliar na escrita e verificação do código.

Ao final da aula, comecei a sentir mais confiança na utilização da linguagem C e na compreensão dos conceitos apresentados. Estou animado para continuar aprendendo e aplicando esses conhecimentos ao longo do curso. Caso surjam dúvidas, agora sei que posso compartilhá-las no fórum ou no Discord recomendados

Comandos e ferramentas em C:

Aprendi a utilizar comandos no terminal, manipular tipos de dados e códigos de formato, compreender operadores matemáticos, implementar estruturas condicionais e loops, além de abordar conceitos fundamentais de memória e imprecisão.

No ambiente virtual CS50 IDE, utilizei comandos como ls, rm, mv, mkdir, e cd para gerenciar arquivos e diretórios. Entendi a importância de tipos de dados como bool, char, double, float, int, long, e string, bem como as funções correspondentes da biblioteca CS50 para obter entrada de diversos tipos.

Exploramos operadores matemáticos como +, -, *, /, e %, e criei programas para realizar cálculos simples. Abordamos o conceito de truncamento ao lidar com operações de divisão entre inteiros e a importância de fazer casting para evitar perda de precisão.

Compreendi a prática de boas práticas de programação, como a utilização de açúcar sintático para incrementar variáveis e a necessidade de seguir convenções de estilo. Implementei estruturas condicionais (if, else if, else) para tomar decisões no código, utilizando operadores de comparação como ==, <, e >.

Aprendi sobre loops, utilizando while e for para criar iterações em programas. Entendi a importância da abstração, criando funções para organizar o código e facilitar a reutilização. Exploramos também a captura de entrada do usuário, a validação de dados e a implementação de loops aninhados para criar padrões de caracteres.

Além disso, discutimos questões relacionadas à memória, imprecisão em cálculos de ponto flutuante e problemas de estouro. Compreendi como os computadores armazenam dados na memória RAM e os desafios associados à representação de números reais com precisão finita.

Ao longo do curso, desenvolvi programas simples e compreendi conceitos fundamentais da linguagem de programação C, preparando-me para explorar tópicos mais avançados nesta jornada de aprendizado.

<details>
  <summary>Mais detalhes exercício Mario/less:</summary>
  Já completei o exercício 1, conhecido como "Mario (versão fácil)", durante o curso. Neste desafio, desenvolvi um programa em C chamado mario.c que recria uma pirâmide de blocos, semelhante à encontrada no jogo Super Mario Brothers da Nintendo, utilizando hashtags (#). Cada hashtag é um pouco mais alto do que largo, proporcionando uma forma piramidal.
  
  O código foi estruturado no diretório [Modulo-01-C/02_mario/mario.c](Modulo-01-C/02_mario/mario.c).. O programa permite que o usuário escolha a altura da pirâmide, solicitando um número inteiro positivo entre 1 e 8, inclusive.
  
  Realizei testes para verificar o funcionamento do programa com diferentes alturas inseridas pelo usuário. Caso o usuário insira um valor inválido (menor que 1, maior que 8 ou não inteiro), o programa solicita uma nova entrada até receber um valor válido.
  
  O pseudocódigo para o exercício foi adicionado ao arquivo [pseudocodigo.txt](Modulo-01-C/02_mario/pseudocodigo.txt) no diretório mario. Este pseudocódigo descreve de forma geral os passos necessários para implementar o programa, destacando a solicitação de altura, a validação da entrada e a iteração para imprimir a pirâmide de hashtags. Este spoiler é apenas uma abordagem para a resolução do exercício, e existem diversas maneiras de implementar o código em C.
  
  Link do teste: [Teste CS50 Mario](https://submit.cs50.io/check50/6d26e9218d295f092e635070e2b95a08eded654a)
</details>

<details>
  <summary>Mais detalhes exercício Mario/more:</summary>
  Já concluí o exercício 2, conhecido como "Mario", durante o curso. Nesse desafio, desenvolvi um programa em C chamado mario.c. A proposta era recriar pirâmides de blocos, semelhantes às encontradas no jogo Super Mario Brothers, utilizando hashtags (#) para representar os tijolos. A altura das pirâmides foi definida pelo usuário, que inseriu um número inteiro positivo entre 1 e 8, inclusivamente.

  O código foi estruturado no diretório [Modulo-01-C/03_mario/mario.c](Modulo-01-C/03_mario/mario.c). Realizei testes para garantir que o programa atendesse a diversos casos de entrada, incluindo números negativos, zero, números de 1 a 8, números maiores que 8, entrada de letras ou palavras, e até mesmo a situação em que nenhum valor é inserido (apenas pressionando Enter).
  
  A "lacuna" entre as pirâmides adjacentes sempre possui a largura de dois hashes, independentemente da altura das pirâmides. Ao finalizar, segui as instruções para testar o código no IDE do CS50, verificando se todas as condições do exercício foram cumpridas, como a correta manipulação de entradas inválidas.
  
  Link do teste: [Teste CS50 Mario](https://submit.cs50.io/check50/90c3744a6e0e7da933006f07e9e7f3c7691eaaa6)
</details>

<details>
  <summary>Mais detalhes exercício Dinheiro:</summary>
  Depois de completar este exercício, entendi a aplicação de algoritmos gananciosos ou ambiciosos ao lidar com situações práticas, como dar troco. A ideia principal é minimizar o número de moedas distribuídas, garantindo eficiência e evitando esgotamento do estoque.
  
  O algoritmo ganancioso escolhe a melhor solução local imediatamente, mesmo que possa não ser a melhor em todos os casos. Por exemplo, ao dar troco usando moedas de 25, 10, 5 e 1 centavo, o algoritmo escolhe a moeda de maior valor possível para cada "mordida". Isso é feito para otimizar a eficiência, reduzindo o problema inicial a problemas menores e mais simples.
  
  A implementação prática desse conceito envolve criar um programa em C chamado cash.c. Este programa pede ao usuário o valor do troco devido, usando get_float para lidar com reais e centavos. O objetivo é imprimir o número mínimo de moedas necessário para o troco, assumindo disponibilidade ilimitada de moedas de 25, 10, 5 e 1 centavo.
  
  O cuidado com a imprecisão dos valores de ponto flutuante é destacado, recomendando a conversão dos valores inseridos pelo usuário em centavos para evitar erros acumulativos. Além disso, o programa deve arredondar os centavos até o último centavo mais próximo usando a função round da biblioteca math.h.
  
  O programa deve lidar com entradas não negativas e solicitar novamente se o usuário fornecer uma quantia inválida. A saída do programa deve ser apenas o número mínimo de moedas, seguido por uma quebra de linha.
  
  Ao finalizar esse exercício, meu entendimento prático sobre algoritmos gananciosos e a aplicação desses conceitos foi solidificado. Agora estou mais confortável em abordar desafios práticos usando essas estratégias.  
  O código foi estruturado no diretório [Modulo-01-C/04_dinheiro/cash.c](Modulo-01-C/04_dinheiro/cash.c).
  
  Link do teste: [Teste CS50 Dinheiro](https://submit.cs50.io/check50/a2014536da2084705556280c9be7e77b6a7799a8)
</details>

<details>
  <summary>Mais detalhes exercício Credit:</summary>
  Já concluí o exercício sobre validação de números de cartão de crédito, compreendendo o funcionamento do algoritmo de Luhn e sua aplicação prática. Agora, sou capaz de explicar como determinar a validade de um número de cartão de crédito usando um programa em C chamado credit.c.
  
  Primeiramente, é essencial entender que os números de cartão de crédito possuem uma estrutura específica, com alguns dígitos iniciais distintos para diferentes empresas. Além disso, eles obedecem ao algoritmo de Luhn, um método inventado por Hans Peter Luhn da IBM, que permite verificar a sintaxe de um número de cartão de crédito.
  
  O algoritmo de Luhn consiste nos seguintes passos:

  - Multiplicar cada segundo dígito por 2, começando com o penúltimo dígito do número, e somar os dígitos - desses produtos.
  - Adicionar essa soma à soma dos dígitos que não foram multiplicados por 2.
  - Se o último dígito do total for 0 (módulo total 10 congruente com 0), o número é considerado válido.

  A implementação prática desse algoritmo envolve escrever um programa em C que solicita ao usuário um número de cartão de crédito, usando get_long para lidar com números longos. O programa então verifica se o número fornecido é um cartão American Express, MasterCard ou Visa válido, seguindo as definições de formato de cada um.
  
  A última linha de saída do programa deve ser AMEX, MASTERCARD, VISA ou INVALID, dependendo do resultado da verificação. É importante lidar com entradas não numéricas e garantir que o usuário forneça um número válido.
  
  Após testar o programa com diversas entradas, tanto válidas quanto inválidas, e corrigir possíveis problemas, estou confiante em minha capacidade de implementar e entender algoritmos práticos em C.

  O código foi estruturado no diretório [Modulo-01-C/05_credit/credit.c](Modulo-01-C/05_credit/credit.c).
  
  Link do teste: [Teste CS50 Credit](https://submit.cs50.io/check50/1c9fa4bd6c64fc84fcb084862c8cf7fd3b815a7a)
</details>

<details>
  <summary>Mais detalhes Laboratório 1 - Crescimento populacional:</summary>
  Concluí o Laboratório 1 sobre crescimento populacional, onde aprendi a calcular o tempo necessário para uma população atingir um determinado tamanho usando programação em C.
  
  Inicialmente, copiei o código fornecido para um novo arquivo chamado population.c no meu IDE. Este código serve como ponto de partida para o desenvolvimento do programa.
  
  O objetivo era solicitar ao usuário o tamanho inicial e final da população e calcular o número de anos necessários para atingir o tamanho final, considerando um modelo de crescimento populacional específico. Neste modelo, a cada ano nascem n/3 novos indivíduos e n/4 morrem.
  
  Implementei o código para solicitar o tamanho inicial e final da população, garantindo que fossem inseridos valores válidos. Se o usuário inserisse valores inválidos, o programa o instruiria a fornecer valores dentro dos limites permitidos.
  
  Utilizei loops do...while para garantir a entrada adequada do usuário. Além disso, empreguei uma variável para controlar o número de anos e atualizei o tamanho da população conforme a fórmula específica do modelo.
  
  Ao final, o programa imprime o número de anos necessário para a população atingir o tamanho final no formato "Years: n".
  
  Testei o código com diversos casos, incluindo diferentes tamanhos iniciais e finais da população. O programa mostrou-se eficaz ao lidar com entradas válidas e inválidas, proporcionando resultados precisos. Este laboratório consolidou minha compreensão sobre loops, condicionais e entrada de dados em C.

  O código foi estruturado no diretório [Modulo-01-C/06_population/population.c](Modulo-01-C/06_population/population.c).
  
  Link do teste: [Teste CS50 Credit](https://submit.cs50.io/check50/a877a9104b3974f35df73d61c09ce1cbea0a597b)
</details>


## <a name="licença"> Licença </a>

<a href="https://www.buymeacoffee.com/claudiomendonca" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 60px !important;width: 217px !important;" ></a>

Copyright © 2024 <a href="https://www.claudiomendonca.eng.br" target="_blank">ClaudioMendonca.eng.br</a> . The [MIT License](https://github.com/ClaudioMendonca-Eng/CS50_Harvard-CC50_Ifood?tab=MIT-1-ov-file) (MIT)
